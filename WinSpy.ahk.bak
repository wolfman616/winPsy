#NoEnv	;	-MWinSpy-	-Window-Info-Tool- ; Fork3d by MWolff
#notrayicon
#SingleInstance,	Off
DetectHiddenWindows,On
DetectHiddenText,	On
SetTitleMatchMode,	2
SetTitleMatchMode,	Slow
Global AppName:= "WinSpy"
if (winexist(AppName " ahk_class AutoHotkeyGUI")) { ; Singleton
	winactivate,
	exitapp,
}
#MaxMem		  640
SetWorkingDir  %A_ScriptDir%
CoordMode Mouse, Screen
SetControlDelay  -1
SetWinDelay	  -1
SetBatchLines	-1
ListLines		Off
#KeyHistory	   0

Menu  Tray, Icon
Menu  Tray, Icon, C:\Icon\48_24\WINSPY48_24.ico
Menu, Tray, noStandard
menu, tray, add, Open Script Folder, Open_Script_Location,
menu, tray, standard
global hOldWnd
, Version:= "1.0.3"
, IniFile:= AppName . ".ini"
, ResDir:= A_ScriptDir . "\Resources"

, hFindTool
, Bitmap1:= "Contact.bmp"
, hCrossHair:= DllCall("LoadImage", "Int", 0
	, "Str", ResDir . "\CrossHair.cur"
	, "Int", 2 ; IMAGE_CURSOR
	, "Int", 32, "Int", 32
	, "UInt", 0x10, "Ptr") ; LR_LOADFROMFILE
, hOldCursor
, Dragging:= False

, g_Borders:= []
, g_hWnd
, hSpyWnd
, hTab
, hStylesTab
, hWindowsTab
, g_Style
, g_ExStyle
, g_ExtraStyle
, g_WinMsgs:= ""
, hCbxMsg
, Cursors:= {}
, oStyles:= {}
, Workaround:= True
, FindDlgExist:= False
, MenuViewerExist:= False
, hTreeWnd:= 0
, TreeIcons:= ResDir . "\TreeIcons.icl"
, ImageList
, g_TreeShowAll:= False
, g_Minimized
, g_MouseCoordMode:= "Screen"
, g_DetectHidden
, g_Minimize
, g_AlwaysOnTop

IniRead g_DetectHidden,% IniFile,Settings,   DetectHidden,0
IniRead g_Minimize,%	 IniFile,Settings,   CompactMode, 0
IniRead g_AlwaysOnTop,%  IniFile,Settings,   AlwaysOnTop, 0
IniRead g_ShowBorder,%   IniFile,Screenshot, ShowBorder,  1
IniRead g_BorderColor,%  IniFile,Screenshot, BorderColor, 0xFF0000
IniRead g_BorderWidth,%  IniFile,Screenshot, BorderWidth, 4
		g_BorderColorTemp:= g_BorderColor
		
; Main window
gui Spy: New, LabelSpy hWndhSpyWnd ; -dpiscale lol dont
	hSmIcon:= LoadPicture("C:\Icon\24\winspy_24.ico", "w24 Icon" . Index, ErrorLevel)
	hLgIcon:= LoadPicture("C:\Icon\48_24\WINSPY48_24.ico", "w48 Icon" . Index, ErrorLevel)
	SendMessage 0x80,0,hSmIcon,,ahk_id %hWnd% ; WM_SETICON, ICON_SMALL
	SendMessage,0x80,1,hLgIcon,,ahk_id%hWnd% ; WM_SETICON, ICON_LARGE
gui,Font,s9,continuum light
gui,Add, Picture, hWndhFindTool gFindToolHandler x10 y7 w32 h32, %Bitmap1%
gui,Add, Text, x48 y10 w220, Drag the Finder Tool over a window`nto select it, then release the mouse
gui,Add, CheckBox, gSetDHW x257 y8 Checked%g_DetectHidden%, &Detect Hidden Windows
gui,Add, CheckBox, vg_Minimize gSetMinimize x257 y28 Checked%g_Minimize%, Compact &Mode
gui,Add, Tab3, hWndhTab vTab gTabHandler x10 y50 w382 h373 AltSubmit -Wrap, General|Styles|Details|Messages|Extra|Windows|Process
; General
gui Tab, 1
	gui Add, Text, x28 y88 w62 h23 +0x200, Handle:
	gui Add, Edit, vEdtHandle gSetHandle x109 y90 w180 h21
	gui Add, Button, hWndhBtnCommands gShowCommandsMenu x297 y88 w83 h23, Commands
	gui Add, Text, vTxtText x28 y119 w62 h21 +0x200, Text:
	gui Add, Edit, vEdtText x109 y120 w180 h21
	gui Add, Button, vBtnSetText gSetText x297 y118 w83 h23, Set Text

	gui Add, Text, x28 y146 w62 h21 +0x200, Class:
	gui Add, Edit, vEdtClass x109 y150 w270 h21 -E0x200 ReadOnly

	gui Add, Text, x28 y176 w62 h21 +0x200, ClassNN:
	gui Add, Edit, vEdtClassNN x109 y180 w270 h21 -E0x200 ReadOnly
	gui Add, Text, x23 y209 w357 0x10

	gui Add, Text, x28 y220 w62 h21 +0x200, Style:
	gui Add, Edit, vEdtStyle x109 y224 w270 h21 -E0x200 ReadOnly
	gui Add, Text, x28 y250 w62 h21 +0x200, Extended:
	gui Add, Edit, vEdtExStyle x109 y254 w270 h21 -E0x200 ReadOnly
	gui Add, Text, x23 y283 w357 0x10

	gui Add, Text, x28 y294 w62 h21 +0x200, Position:
	gui Add, Edit, vEdtPosition x109 y298 w180 h21 -E0x200 ReadOnly
	gui Add, Button, gShowXYWHDlg x297 y294 w83 h23, Change...
	gui Add, Text, x28 y324 w62 h21 +0x200, Size:
	gui Add, Edit, vEdtSize x109 y328 w180 h21 -E0x200 ReadOnly
	gui Add, Text, x23 y357 w357 0x10

	gui Add, Text, x28 y368 w80 h21 +0x200, Cursor:
	gui Add, Edit, vEdtCursor x109 y372 w180 h21 -E0x200 ReadOnly
	gui Add, DropDownList, vMouseCoordMode gSetMouseCoordMode x297 y368 w83, Client|Window|Screen||
; Styles
gui Tab, 2
	gui Add, Custom, ClassSysTabControl32 hWndhStylesTab gStylesTabHandler x21 y85 w360 h230
	Tab_AddItem(hStylesTab, "Styles")
	Tab_AddItem(hStylesTab, "Extended Styles")

	; ListBox style +0x108: no integral height and simplified multiple selection
	gui Add, ListBox
		, hWndhLbxStyles vLbxStyles gLbxStylesHandler x28 y116 w344 h190 +0x108 -E0x200 T133
	gui Add, ListBox
		, hWndhLbxExStyles vLbxExStyles gLbxStylesHandler x28 y116 w344 h190 +0x108 -E0x200 T133 Hidden
	gui Add, ListBox
		, hWndhLbxExtraStyles vLbxExtraStyles gLbxStylesHandler x28 y116 w344 h190 +0x108 -E0x200 T133 Hidden

	gui Add, GroupBox, vGrpDesc x21 y319 w268 h91, Description
	gui Add, Text, vTxtDesc gShowDescription x32 y338 w245 h64 +0x80, Left/Right-click an item to see its description.

	gui Add, Edit, vEdtStyleSum x297 y326 w83 h23, 0x00000000
	gui Add, Edit, vEdtExStyleSum x297 y326 w83 h23 Hidden, 0x00000000
	gui Add, Edit, vEdtExtraStyleSum x297 y326 w83 h23 Hidden, 0x00000000

	gui Add, Button, gApplyStyle x297 y355 w83 h24, Apply
	gui Add, Button, gResetStyle x297 y386 w83 h24, Reset

; Details
gui Tab, 3
	gui Add, ListView, hWndhClassInfo x21 y84 w360 h200 +LV0x14000, Property|Value
	LV_ModifyCol(1, 138)
	LV_ModifyCol(2, 201)

	gui Add, Text, x21 y288 w360 h20, Window Properties:
	gui Add, ListView, hWndhPropInfo x21 y306 w360 h104 +LV0x14000, Property|Data
	LV_ModifyCol(1, 238)
	LV_ModifyCol(2, 100)

; Messages
gui Tab, 4
	gui Add, Text, x30 y94 w63 h23 +0x200, Message:
	gui Add, ComboBox, hWndhCbxMsg vCbxMessages x105 y94 w182
	SendMessage 0x1701, 20, 0,, ahk_id %hCbxMsg% ; CB_SETMINVISIBLE
	gui Add, Link, gGoogleSearch x299 y97 w78 h23, <a>Google Search</a>
	gui Add, Text, x30 y127 w63 h23 +0x200, wParam:
	gui Add, Edit, vwParam x105 y127 w182 h23
	gui Add, DropDownList, vwParamType x297 y126 w78, Number||String
	gui Add, Text, x30 y161 w63 h23 +0x200, lParam:
	gui Add, Edit, vlParam x105 y161 w182 h23
	gui Add, DropDownList, vlParamType x297 y160 w78, Number||String
	gui Add, Button, gSendMsg x97 y206 w99 h24, SendMessage
	gui Add, Button, gPostMsg x203 y206 w99 h24, PostMessage
	gui Add, GroupBox, x84 y242 w232 h51 Center, Result
	gui Add, Edit, vResult x103 y264 w195 h21 Center -E0x200 ReadOnly
	gui Add, Picture, x58 y390 w16 h16 +Icon2, user32.dll
	gui Add, Text, x80 y390 w290 h23, Some messages may crash the target application.
; Extra
gui Tab, 5
	gui Add, ListView, hWndhExtraInfo x21 y84 w360 h261 +LV0x14000, Property|Value

	gui Add, Button, hWndhBtnMenu gShowMenuViewer x21 y355 w83 h23, Menu...
	gui Add, Button, gShowScrollBarInfo x21 y387 w83 h23, Scroll Bars...

; Windows
gui Tab, 6
	gui Add, Custom, ClassSysTabControl32 hWndhWindowsTab gWindowsTabHandler x21 y85 w360 h255
	Tab_AddItem(hWindowsTab, "Child Windows")
	Tab_AddItem(hWindowsTab, "Sibling Windows")

	gui Add, ListView, hWndhChildList gChildListHandler x28 y116 w344 h214 -E0x200 +LV0x14000
	, Handle|Class Name|Window Text
	LV_ModifyCol(1, 76)
	LV_ModifyCol(2, 113)
	LV_ModifyCol(3, 136)
	gui Add, ListView, hWndhSiblingList gSiblingListHandler x28 y116 w344 h214 -E0x200 +LV0x14000 Hidden
	, Handle|Class Name|Window Text
	LV_ModifyCol(1, 76)
	LV_ModifyCol(2, 113)
	LV_ModifyCol(3, 136)

	gui Add, Text, x33 y352 w48 h23 +0x200, Parent:
	gui Add, Link, vParentLink gLinkToHandle x87 y357 w300 h20, <a>0x00000000</a>
	gui Add, Text, x33 y380 w48 h23 +0x200, Owner:
	gui Add, Link, vOwnerLink gLinkToHandle x87 y385 w300 h20, <a>0x00000000</a>

; Process
gui Tab, 7
	gui Add, Picture, vProgIcon x21 y82 w32 h32 Icon3, shell32.dll
	gui Add, Text, vProgName x60 y82 w180 h20, N/A
	gui Add, Text, vProgVer x60 y96 w180 h20 +0x200
	gui Add, ListView, hWndhProcInfo x21 y120 w360 h257 +LV0x14000, Property|Value
	LV_ModifyCol(1, 100)
	LV_ModifyCol(2, 256)
	gui Add, Button, gEndProcess x21 y386 w83 h23, End Process
	gui Add, Button, gOpenFolder x110 y386 w83 h23, Open Folder

gui Tab
gui Add, Button, hWndhBtnOpts gShowSettingsDlg x10 y432 w24 h24
gui Add, Button, gShowFindDlg x39 y432 w84 h24, &Find...
gui Add, Button, gShowTree x128 y432 w84 h24, &Tree...
gui Add, Button, gCopyToClipboard x217 y432 w84 h24, &Copy
gui Add, Button, gScreenshot x306 y432 w84 h24, &Screenshot

SetButtonIcon(hBtnOpts, ResDir . "\Settings.ico")

; Show main window
IniRead px, %IniFile%, Settings, x, Center
IniRead py, %IniFile%, Settings, y, Center
gui, Show, x%px% y%py% w400 h465 Hide, %AppName% ; Show main window
if (g_Minimize) {
	WinMove ahk_id %hSpyWnd%,,,,, 78
	g_Minimized:= True
}
gui, Show

SetExplorerTheme(hClassInfo)
SetExplorerTheme(hPropInfo)
SetExplorerTheme(hExtraInfo)
SetExplorerTheme(hChildList)
SetExplorerTheme(hSiblingList)
SetExplorerTheme(hProcInfo)

; Commands menu
Menu CommandsMenu, Add, Visible, MenuHandler
Menu CommandsMenu, Add, Enabled, MenuHandler
Menu CommandsMenu, Add, Always on Top, MenuHandler
Menu CommandsMenu, Add
Menu CommandsMenu, Add, Redraw Window, MenuHandler
Menu CommandsMenu, Add
Menu CommandsMenu, Add, Close Window, MenuHandler
Global hCommandsMenu:= MenuGetHandle("CommandsMenu")

RegRead Sep, HKEY_CURRENT_USER\Control Panel\International, sThousand
if (Sep == "") {
	Sep:= "."
}

OnMessage(0x100, "OnWM_KEYDOWN")
OnMessage(0x112, "OnWM_SYSCOMMAND")
OnMessage(0x200, "OnWM_MOUSEMOVE")
OnMessage(0x202, "OnWM_LBUTTONUP")
OnMessage(0x204, "OnWM_RBUTTONDOWN")

LoadCursors()

hSysMenu:= DllCall("GetSystemMenu", "Ptr", hSpyWnd, "Int", False, "Ptr")
DllCall("InsertMenu", "Ptr", hSysMenu, "UInt", 5, "UInt", 0x400, "UPtr", 0xC0DE, "Str", "About...")
DllCall("InsertMenu", "Ptr", hSysMenu, "UInt", 5, "UInt", 0xC00, "UPtr", 0, "Str", "") ; Separator

return, ; End of the auto-execute section
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~space::
PostMessage,0x0202,0,0,,ahk_id %hSpyWnd% ;WM_LBUTTONUP 0x0202;
return,

SpyEscape:
SpyClose:
	p:= GetWindowPlacement(hSpyWnd)

	if (!FileExist(IniFile))
		FileAppend % "[Settings]`n`n[Screenshot]", %IniFile%, UTF-16

	IniWrite % p.x, %IniFile%, Settings, x
	IniWrite % p.y, %IniFile%, Settings, y

	IniWrite %g_DetectHidden%, %IniFile%, Settings, DetectHidden
	IniWrite %g_Minimize%, %IniFile%, Settings, CompactMode
	IniWrite %g_AlwaysOnTop%, %IniFile%, Settings, AlwaysOnTop

	IniWrite %g_ShowBorder%, %IniFile%, Screenshot, ShowBorder
	IniWrite %g_BorderColor%, %IniFile%, Screenshot, BorderColor
	IniWrite %g_BorderWidth%, %IniFile%, Screenshot, BorderWidth

	ExitApp,

IsChild(hWnd) {
	WinGet,Style,Style,ahk_id %hWnd%
	return,Style & 0x40000000 ; WS_CHILD
}

ShowWindowInfo(ClassNN:= "") {
	guiControl -g, EdtHandle

	if (IsChild(g_hWnd)) {
		LoadControlInfo(ClassNN)
	} else {
		LoadWindowInfo()
	}

	guiControl +gSetHandle, EdtHandle

	GoSub,LoadStyles
	GoSub,LoadClassInfo
	GoSub,LoadProperties
	GoSub,LoadExtraInfo
	GoSub,LoadWindowsTab

	guiControlGet Tab,, Tab, %hTab%
	TabHandler(Tab)

	GoSub,UpdateTitleBar
}

LoadWindowInfo() {
	gui,Spy: Default
	; Handle
	guiControl,,EdtHandle,% Format("0x{:X}", g_hWnd)
	; Title
	WinGetTitle Title, ahk_id %g_hWnd%
	guiControl,,EdtText,% Title
	guiControl,,TxtText, Title:
	guiControl,,BtnSetText, Set Title
	; Class
	WinGetClass,Class,ahk_id %g_hWnd%
	guiControl,,EdtClass,% Class
	guiControl,,EdtClassNN, N/A
	; Style
	WinGet,g_Style,Style,ahk_id %g_hWnd%
	if ((g_Style & 0x00FF0000) == 0xCF0000)
		StyleInfo:= " (overlapped window)"
	else,if (g_Style & 0x80880000) 
		StyleInfo:= " (popup window)"
	else,StyleInfo:= ""
	guiControl,,EdtStyle,% Format("0x{:08X}",g_Style) . StyleInfo
	; Extended style
	WinGet,g_ExStyle,ExStyle, ahk_id %g_hWnd%
	guiControl,, EdtExStyle, % Format("0x{:08X}", g_ExStyle)
	; Position/size
	SetFormat Integer, D
	WinGetPos X, Y, W, H, ahk_id %g_hWnd%
	wi:= GetWindowInfo(g_hWnd)
	guiControl,, EdtPosition, % X . ", " . Y . " (" . wi.ClientX . ", " . wi.ClientY . ")"
	guiControl,, EdtSize, % W . " x " . H . " (" . wi.ClientW . " x " . wi.ClientH . ")"
}

LoadControlInfo(ClassNN) {
	(ClassNN == ""? ClassNN:= GetClassNNEx(g_hWnd))
	gui,Spy:	Default
	SetFormat,	Integer,Hex
	; Handle
	guiControl,,EdtHandle,% Format("0x{:X}", g_hWnd)
	; Class
	WinGetClass,Class,ahk_id %g_hWnd%
	guiControl,,EdtClass,% Class
	; Control text
	ControlGetText,Text,,ahk_id %g_hWnd%
	guiControl,,EdtText,% 	Text
	guiControl,,TxtText, 	Text:
	guiControl,,BtnSetText,Set Text
	; ClassNN
	guiControl,,EdtClassNN,% ClassNN
	; Style
	ControlGet,	g_Style,Style,,,ahk_id %g_hWnd%
	guiControl,,EdtStyle,% g_Style
	; Extended style
	ControlGet,g_ExStyle,ExStyle,,,ahk_id %g_hWnd%
	guiControl,,EdtExStyle,% g_ExStyle
	; Position/Size
	SetFormat,Integer, D
	GetWindowPos(g_hWnd,X,Y,W,H)
	wi:= GetWindowInfo(g_hWnd)
	Pos:= X . ", " . Y ; Relative to parent

	hParent:= GetParent(g_hWnd)
	hAncestor:= GetAncestor(g_hWnd)
	if (hParent != hAncestor) {
		VarSetCapacity(RECT,16,0)
		DllCall("GetWindowRect","Ptr",g_hWnd,"Ptr",&RECT)
		DllCall("MapWindowPoints","Ptr",0,"Ptr",GetAncestor(g_hWnd),"Ptr",&RECT, "UInt", 1)
		AX:= NumGet(RECT,0,"Int")
		AY:= NumGet(RECT,4,"Int")
		Pos .= " (" . AX ", " . AY . ")" ; Relative to ancestor
	}

	guiControl,, EdtPosition, %Pos%

	if (W != wi.ClientW || H != wi.ClientH) {
		guiControl,,EdtSize,% W . " x " . H . " (" . wi.ClientW . " x " . wi.ClientH . ")"
	} else {
		guiControl,, EdtSize, %W% x %H%
	}

	g_ExtraStyle:= GetExtraStyle(g_hWnd)
}

GetStatusBarText(hWnd) {
	SB_Text:= ""
	hParentWnd:= GetParent(hWnd)

	SendMessage 0x406, 0, 0,, ahk_id %hWnd% ; SB_GETPARTS
	Count:= ErrorLevel
	if (Count != "FAIL") {
		Loop %Count% {
			StatusBarGetText PartText, %A_Index%, ahk_id %hParentWnd%
			SB_Text .= PartText . "|"
		}
	}

	return, SubStr(SB_Text, 1, -1)
}

TabHandler:
	gui Spy: Submit, NoHide
	TabHandler(Tab)
return,

TabHandler(Tab) {
	if (Tab == 7) { ; Process
		GoSub LoadProcessProperties
	} else if (Tab == 4) { ; Messages
		GoSub LoadMessages
		WinSet Redraw,, ahk_id %hCbxMsg%
	}
}

; Flag: GA_PARENT = 1, GA_ROOT = 2, GA_ROOTOWNER  = 3
GetAncestor(hWnd, Flag:= 2) {
	return, DllCall("GetAncestor", "Ptr", hWnd, "UInt", Flag, "Ptr")
}

GetClassNNEx(hWnd) {
	hAncestor:= GetAncestor(hWnd)
	if (!hAncestor) {
		return,
	}

	WinGetClass BaseClass, ahk_id %hWnd%
	NN:= 0

	WinGet ControlList, ControlListHwnd, % "ahk_id " . hAncestor
	Loop Parse, ControlList, `n
	{
		WinGetClass Class, ahk_id %A_LoopField%
		if (Class == BaseClass) {
			NN++
			if (A_LoopField == hWnd) {
				return, Class . NN
			}
		}
	}
}

SetHandle:
	gui Spy: Submit, NoHide
	if (!Dragging&&WinExist("ahk_id " . EdtHandle)) {
		g_hWnd:=EdtHandle
		ShowWindowInfo()
	}
return,

MenuHandler:
	if (A_ThisMenuItem == "Visible") {
		ShowWindow(g_hWnd, !IsWindowVisible(g_hWnd))
	} else if (A_ThisMenuItem == "Enabled") {
		DllCall("EnableWindow", "Ptr", g_hWnd, "UInt", !IsWindowEnabled(g_hWnd))
	} else if (A_ThisMenuItem == "Always on Top") {
		WinSet AlwaysOnTop, Toggle, ahk_id %g_hWnd%
	} else if (A_ThisMenuItem == "Close Window") {
		WinClose ahk_id %g_hWnd%
	} else if (A_ThisMenuItem == "Redraw Window") {
		WinSet Redraw,, ahk_id %g_hWnd%
	}
return,

UpdateCommandsMenu() {
	Visible:= IsWindowVisible(g_hWnd)
	Enabled:= IsWindowEnabled(g_hWnd)
	WinGet ExStyle, ExStyle, ahk_id %g_hWnd%

	Menu CommandsMenu, % (Visible) ? "Check" : "Uncheck", Visible
	Menu CommandsMenu, % (Enabled) ? "Check" : "Uncheck", Enabled

	Menu CommandsMenu, % (ExStyle & 0x8) ? "Check" : "Uncheck", Always on Top ; WS_EX_TOPMOST
	Menu CommandsMenu, % (IsChild(g_hWnd)) ? "Disable" : "Enable", Always on Top
}

IsWindowEnabled(hWnd) {
	return, DllCall("IsWindowEnabled", "Ptr", hWnd)
}

ShowCommandsMenu:
	UpdateCommandsMenu()

	Flags:= 0x8 ; TPM_TOPALIGN | TPM_RIGHTALIGN
	WingetPos wx, wy, ww, wh, ahk_id %hSpyWnd%
	ControlGetPos cx, cy, cw, ch,, ahk_id %hBtnCommands%
	x:= wx + cx + cw
	y:= wy + cy + ch
	DllCall("TrackPopupMenu", "Ptr", hCommandsMenu, "UInt", 0x8, "Int", x, "Int", y, "Int", 0, "Ptr", hSpyWnd, "Ptr", 0)
return,

SetText:
	gui Spy: Submit, NoHide
	if (IsChild(g_hWnd)) {
		ControlSetText,, %EdtText%, ahk_id %g_hWnd%
	} else {
		WinSetTitle ahk_id %g_hWnd%,, %EdtText%
	}
return,

ShowBorder(hWnd, Duration:= 500, Color:= "0x3FBBE3", r:= 3) {
	Local x, y, w, h, Index

	WinGetPos x, y, w, h, ahk_id %hWnd%
	if (!w) {
		return,
	}

	g_Borders:= []
	Loop 4 {
		Index:= A_Index + 90
		gui %Index%: +hWndhBorder -Caption +ToolWindow +AlwaysOnTop -dpiscale
		gui %Index%: Color, %Color%
		g_Borders.Push(hBorder)
	}

	gui 91: Show, % "NA x" (x - r) " y" (y - r) " w" (w + r + r) " h" r ; Top
	gui 92: Show, % "NA x" (x - r) " y" (y + h) " w" (w + r + r) " h" r ; Bottom
	gui 93: Show, % "NA x" (x - r) " y" y " w" r " h" h ; Left
	gui 94: Show, % "NA x" (x + w) " y" y " w" r " h" h ; Right

	if (Duration != -1) {
		Sleep %Duration%
		Loop 4 {
			Index:= A_Index + 90
			gui %Index%: Destroy
		}
	}
}

GetClassLong(hWnd, Param) {
	Static GetClassLong:= A_PtrSize == 8 ? "GetClassLongPtr" : "GetClassLong"
	return, DllCall(GetClassLong, "Ptr", hWnd, "Int", Param)
}

GetWindowLong(hWnd, Param) {
	;GetWindowLong:= A_PtrSize == 8 ? "GetWindowLongPtr" : "GetWindowLong"
	return, DllCall("GetWindowLong", "Ptr", hWnd, "Int", Param)
}

; Details
LoadClassInfo:
	gui ListView, %hClassInfo%
	LV_Delete()

	SetFormat Integer, H
	WinGetClass ClassName, ahk_id %g_hWnd%
	ClassStyle:= GetClassLong(g_hWnd, -26)

	LV_Add("", "Class name", ClassName)
	LV_Add("", "Control ID", GetWindowLong(g_hWnd, -12))
	LV_Add("", "Font", GetFont())
	LV_Add("", "Window procedure", GetClassLong(g_hWnd, -24))
	LV_Add("", "Instance handle", GetClassLong(g_hWnd, -16))
	LV_Add("", "Class style", ClassStyle . GetClassStyles(ClassStyle))
	LV_Add("", "Icon handle", GetClassLong(g_hWnd, -14))
	LV_Add("", "Small icon handle", GetClassLong(g_hWnd, -34))
	LV_Add("", "Cursor handle", GetCursor(GetClassLong(g_hWnd, -12)))
	LV_Add("", "Background Brush", GetSysColorName(GetClassLong(g_hWnd, -10) - 1))
	LV_Add("", "Menu name", GetClassLong(g_hWnd, -8))
	LV_Add("", "Window extra bytes", GetClassLong(g_hWnd, -18))
	LV_Add("", "Class extra bytes", GetClassLong(g_hWnd, -20))
	LV_Add("", "Class atom", GetClassLong(g_hWnd, -32))
	LV_Add("", "User data", GetWindowLong(g_hWnd, -21))
	SetFormat Integer, D
	LV_Add("", "Unicode", DllCall("IsWindowUnicode", "Ptr", g_hWnd) ? "Yes" : "No")
	LV_Add("", "Tab order index", GetTabOrderIndex(g_hWnd))
	LV_Add("", "Help context ID", DllCall("GetWindowContextHelpId", "Ptr", g_hWnd))
	LV_Add("", "Touch-capable", DllCall("IsTouchWindow", "Ptr", g_hWnd, "Ptr", 0))
return,

GetFont() {
	FontName:= FontSize:= FontStyle:= ""

	Wingetclass Class, ahk_id %g_hWnd%
	if (Class == "Scintilla") {
		FontName:= Scintilla_GetFont(g_hWnd)
		FontSize:= SendMsg(2485, 32) ; SCI_STYLEGETSIZE, STYLE_DEFAULT
	} else {
		Control_GetFont(g_hWnd, FontName, FontSize, FontStyle)
		if (FontName == "" || FontSize > 1000) {
			return, "System default"
		}
	}
	FontInfo:= FontName . ", " . Format("{:d}", FontSize)
	if (FontStyle != "") {
		FontInfo .= ", " . FontStyle
	}
	return, FontInfo
}
; www.autohotkey.com/forum/viewtopic.php?p=465438#465438
Control_GetFont(hWnd, ByRef Name, ByRef Size, ByRef Style, IsGDIFontSize:= 0) {
	SendMessage 0x31, 0, 0, , ahk_id %hWnd% ; WM_GETFONT
	if (ErrorLevel == "FAIL") {
		return,
	}

	hFont:= Errorlevel
	VarSetCapacity(LOGFONT, LOGFONTSize:= 60 * (A_IsUnicode ? 2 : 1 ))
	DllCall("GetObject", "Ptr", hFont, "Int", LOGFONTSize, "Ptr", &LOGFONT)

	Name:= DllCall("MulDiv", "Int", &LOGFONT + 28, "Int", 1, "Int", 1, "Str")

	Style:= Trim((Weight:= NumGet(LOGFONT, 16, "Int")) == 700 ? "Bold" : (Weight == 400) ? "" : " w" . Weight
	. (NumGet(LOGFONT, 20, "UChar") ? " Italic" : "")
	. (NumGet(LOGFONT, 21, "UChar") ? " Underline" : "")
	. (NumGet(LOGFONT, 22, "UChar") ? " Strikeout" : ""))

	Size:= IsGDIFontSize ? -NumGet(LOGFONT, 0, "Int") : Round((-NumGet(LOGFONT, 0, "Int") * 72) / A_ScreenDPI)
}

Scintilla_GetFont(hWnd) {
	WinGet PID, PID, ahk_id %hWnd%
	if !(hProc:= DllCall("OpenProcess", "UInt", 0x438, "Int", False, "UInt", PID, "Ptr")) {
		return,
	}

	; LF_FACESIZE:= 32
	Address:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0, "UPtr", 32, "UInt", 0x1000, "UInt", 4, "Ptr")

	SendMessage 2486, 32, Address,, ahk_id %hWnd% ; SCI_STYLEGETFONT, STYLE_DEFAULT
	if (ErrorLevel != "FAIL") {
		VarSetCapacity(FontName, 32, 0)
		DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", Address, "Ptr", &FontName, "UPtr", 32, "Ptr", 0)
		FontName:= StrGet(&FontName, "UTF-8")
	}

	DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", Address, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	DllCall("CloseHandle", "Ptr", hProc)

	return, FontName
}

Scintilla_GetLexerLanguage(hWnd) {
	WinGet PID, PID, ahk_id %hWnd%
	if !(hProc:= DllCall("OpenProcess", "UInt", 0x438, "Int", False, "UInt", PID, "Ptr")) {
		return,
	}

	Sendmessage 4012, 0, 0,, ahk_id %hWnd% ; SCI_GETLEXERLANGUAGE
	BufferSize:= ErrorLevel
	Address:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0, "UPtr", BufferSize, "UInt", 0x1000, "UInt", 4, "Ptr")

	Sendmessage 4012, 0, Address,, ahk_id %hWnd% ; SCI_GETLEXERLANGUAGE
	if (ErrorLevel != "FAIL") {
		VarSetCapacity(LexerName, BufferSize, 0)
		DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", Address, "Ptr", &LexerName, "UPtr", 32, "Ptr", 0)
		LexerName:= StrGet(&LexerName, "UTF-8")
	}

	DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", Address, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	DllCall("CloseHandle", "Ptr", hProc)

	return, LexerName
}

GetClassStyles(Style) {
	Static CS:= {0x1: "CS_VREDRAW"
	, 0x2: "CS_HREDRAW"
	, 0x8: "CS_DBLCLKS"
	, 0x20: "CS_OWNDC"
	, 0x40: "CS_CLASSDC"
	, 0x80: "CS_PARENTDC"
	, 0x200: "CS_NOCLOSE"
	, 0x800: "CS_SAVEBITS"
	, 0x1000: "CS_BYTEALIGNCLIENT"
	, 0x2000: "CS_BYTEALIGNWINDOW"
	, 0x4000: "CS_GLOBALCLASS"
	, 0x10000: "CS_IME"
	, 0x20000: "CS_DROPSHADOW"}

	Styles:= " ("
	For k, v in CS {
		if (Style & k) {
			Styles .= v ", "
		}
	}

	return, RTrim(Styles, ", ") . ")"
}

LoadCursors() {
	Static Constants:= {"IDC_ARROW": 32512
		, "IDC_IBEAM": 32513
		, "IDC_WAIT": 32514
		, "IDC_CROSS": 32515
		, "IDC_UPARROW": 32516
		, "IDC_SIZENWSE": 32642
		, "IDC_SIZENESW": 32643
		, "IDC_SIZEWE": 32644
		, "IDC_SIZENS": 32645
		, "IDC_SIZEALL": 32646
		, "IDC_NO": 32648
		, "IDC_HAND": 32649
		, "IDC_APPSTARTING": 32650
		, "IDC_HELP": 32651}

	For Key, Value in Constants {
		hCursor:= DllCall("LoadCursor", "Ptr", 0, "UInt", Value, "Ptr")
		Cursors[hCursor]:= Key
	}
}

GetCursor(CursorHandle) {
	Cursor:= Cursors[CursorHandle]
	return, (Cursor != "") ? Cursor : CursorHandle
}

GetTabOrderIndex(hWnd) {
	hParent:= GetAncestor(hWnd)

	WinGet ControlList, ControlListHwnd, ahk_id %hParent%
	Index:= 1
	Loop Parse, ControlList, `n
	{
		if (!IsWindowVisible(A_LoopField)) {
			Continue
		}

		WinGet Style, Style, ahk_id %A_LoopField%
		if !(Style & 0x10000) { ; WS_TABSTOP
			Continue
		}

		if (A_LoopField == hWnd) {
			return, Index
		}

		Index++
	}

	return, 0
}

Tab_AddItem(hTab, Text) {
	VarSetCapacity(TCITEM, 16 + A_PtrSize * 3, 0)
	NumPut(0x1, TCITEM, 0, "UInt") ; TCIF_TEXT
	NumPut(&Text, TCITEM, 8 + A_PtrSize, "Ptr")
	SendMessage 0x1304, 0, 0,, ahk_id %hTab% ; TCM_GETITEMCOUNT
	SendMessage 0x133E, %ErrorLevel%, &TCITEM, , ahk_id %hTab% ; TCM_INSERTITEMW
}

StylesTabHandler:
	if (A_guiEvent == "N") {
		Code:= NumGet(A_EventInfo + 0, A_PtrSize * 2, "Int")
		if (Code == -551) { ; TCN_SELCHANGE
			SendMessage 0x130B, 0, 0,, ahk_id %hStylesTab% ; TCM_GETCURSEL
			nTab:= Errorlevel + 1
			if (nTab == 1) {
				guiControl Hide, ListBox3
				guiControl Hide, ListBox2
				guiControl Show, ListBox1

				guiControl Hide, EdtExtraStyleSum
				guiControl Hide, EdtExStyleSum
				guiControl Show, EdtStyleSum
			} else if (nTab == 2) {
				guiControl Hide, ListBox1
				guiControl Hide, ListBox3
				guiControl Show, ListBox2

				guiControl Hide, EdtExtraStyleSum
				guiControl Hide, EdtStyleSum
				guiControl Show, EdtExStyleSum
			} else if (nTab == 3) {
				guiControl Hide, ListBox1
				guiControl Hide, ListBox2
				guiControl Show, ListBox3

				guiControl Hide, EdtStyleSum
				guiControl Hide, EdtExStyleSum
				guiControl Show, EdtExtraStyleSum
			}
		}
	}
return,

; Styles
LoadStyles:
	gui Spy: Default

	guiControl,, EdtStyleSum, %g_Style%
	guiControl,, EdtExStyleSum, %g_ExStyle%
	guiControl,, EdtExtraStyleSum, %g_ExtraStyle%

	WinGetClass Class, ahk_id %g_hWnd%
	if (Class == "") {
		return,
	}

	; Load control styles
	LoadStyles(Class, "ListBox1")

	if (Class == "ToolbarWindow32" || Class == "ReBarWindow32") {
		LoadStyles("CommonControls", "ListBox1", True)
	}

	; Load window styles
	LoadStyles("Window", "ListBox1", True)
	LoadStyles("WindowEx", "ListBox2")

	; Delete the third tab
	SendMessage 0x1308, 2, 0,, ahk_id %hStylesTab% ; TCM_DELETEITEM
	if (ErrorLevel == True) {
		guiControl Hide, ListBox3
		guiControl Show, ListBox1
		SendMessage 0x1330, 0, 0,, ahk_id %hStylesTab% ; TCM_SETCURFOCUS
		Sleep 0
		SendMessage 0x130C, 0, 0,, ahk_id %hStylesTab% ; TCM_SETCURSEL
	}

	if (Class == "ComboBox" && g_Style & 0x10) { ; CBS_OWNERDRAWFIXED
		Class:= "ComboBoxEx"
	}

	; Add third tab
	if (Class == "SysListView32"
	||  Class == "SysTreeView32"
	||  Class == "SysTabControl32"
	||  Class == "ToolbarWindow32"
	||  Class == "ComboBoxEx") {
		Tab_AddItem(hStylesTab, RegExReplace(Class, "Sys|32|Control|Window") . " Extended Styles")
		LoadStyles(Class . "Ex", "ListBox3")
	}

	WStyle:= g_Style
	Type:= 0
	if (Class == "Button") {
		Type:= WStyle & 0xF ; BS_TYPEMASK
		WStyle &= ~Type
	} else if (Class == "SysListView32") {
		Type:= WStyle & 0x3 ; LVS_TYPEMASK
		WStyle &= ~Type
	} else if (Class == "Static") {
		Type:= WStyle & 0x1F ; SS_TYPEMASK
		WStyle &= ~Type
	}

	ControlGet Items, List,,, ahk_id %hLbxStyles%
	Loop Parse, Items, `n
	{
		LStyle:= StrSplit(A_LoopField, "`t")[2]
		if (WStyle & LStyle || Type == LStyle) {
			WStyle &= ~LStyle
			guiControl Choose, %hLbxStyles%, %A_Index%
		}
	}

	if (WStyle) {
		Leftover:= Format("0x{:08X}", WStyle)
		guiControl,, %hLbxStyles%, % Leftover . "`t" . Leftover . "||"
	}

	SendMessage 0x115, 6, 0,, ahk_id %hLbxStyles% ; WM_VSCROLL, scroll to top
	WinSet Redraw,, ahk_id %hLbxStyles%

	; Extended styles
	WExStyle:= g_ExStyle
	ControlGet Items, List,,, ahk_id %hLbxExStyles%
	Loop Parse, Items, `n
	{
		LExStyle:= StrSplit(A_LoopField, "`t")[2]
		if (WExStyle & LExStyle || LExStyle == 0) {
			WExStyle &= ~LExStyle
			guiControl Choose, %hLbxExStyles%, %A_Index%
		}
	}

	if (WExStyle) {
		Leftover:= Format("0x{:08X}", WExStyle)
		guiControl,, %hLbxExStyles%, % Leftover . "`t" . Leftover . "||"
	}

	SendMessage 0x115, 6, 0,, ahk_id %hLbxExStyles% ; WM_VSCROLL, scroll to top
	WinSet Redraw,, ahk_id %hLbxExStyles%

	; Extra control styles (LV, TV, Toolbar, Tab)
	ExtraStyle:= g_ExtraStyle
	ControlGet Items, List,,, ahk_id %hLbxExtraStyles%
	Loop Parse, Items, `n
	{
		LExtraStyle:= StrSplit(A_LoopField, "`t")[2]
		if (ExtraStyle & LExtraStyle || LExtraStyle == 0) {
			ExtraStyle &= ~LExtraStyle
			guiControl Choose, %hLbxExtraStyles%, %A_Index%
		}
	}
return,

LoadStyles(IniSection, ListBox, Append:= False) {
	Static IniFile:= A_ScriptDir . "\Constants\Styles.ini"
	IniRead Section, %IniFile%, %IniSection%

	Child:= (IniSection == "Window" && IsChild(g_hWnd)) ? True : False

	Values:= ""
	Loop Parse, Section, `n
	{
		Fields:= StrSplit(A_LoopField, "|")
		Const:= Fields[1]

		if (Child && (Const == "WS_MAXIMIZEBOX" || Const == "WS_MINIMIZEBOX" || Const == "WS_OVERLAPPED")) {
			Continue
		}

		if (!Child && (Const == "WS_TABSTOP" || Const == "WS_GROUP")) {
			Continue
		}

		Values .= Const . "`t" . Fields[2] . "|"
		oStyles[Const]:= {"Value": Fields[2], "Desc": Fields[3]}
	}

	gui Spy: Default
	guiControl,, %ListBox%, % (Append) ? Values : "|" . Values
}

LbxStylesHandler:
	gui Spy: Default
	guiControlGet hLbx, hWnd, %A_guiControl%
	guiControl -AltSubmit, %hLbx%

	guiControlGet Items,, %hLbx%

	Sum:= 0
	Loop Parse, Items, |
	{
		StringSplit Field, A_LoopField, `t
		Sum += Field2
	}

	guiControl,, % StrReplace(A_guiControl, "Lbx", "Edt") . "um", % Format("0x{:08X}", Sum)

	; Style description
	guiControl +AltSubmit, %hLbx%
	SendMessage 0x188, 0, 0,, ahk_id %hLbx% ; LB_GETCURSEL
	if (ErrorLevel != "FAIL") {
		; Credits to just_me
		Index:= ErrorLevel
		SendMessage 0x18A, %Index%, 0,, ahk_id %hLbx% ; LB_GETTEXTLEN
		Len:= ErrorLevel
		VarSetCapacity(LB_Text, Len << !!A_IsUnicode, 0)
		SendMessage 0x189, %Index%, % &LB_Text,, ahk_id %hLbx% ; LB_GETTEXT
		Const:= StrSplit(StrGet(&LB_Text, Len), "`t")[1]
		Desc:= StrReplace(oStyles[Const].Desc, "\n", "`n")
		guiControl,, GrpDesc, %Const%
		guiControl,, TxtDesc, %Desc%
		;msgbox % Desc " " Const
		}
return,

ApplyStyle:
	SendMessage 0x130B, 0, 0,, ahk_id %hStylesTab% ; TCM_GETCURSEL
	nTab:= ErrorLevel + 1
	if (nTab == 1) {
		guiControlGet Style,, EdtStyleSum
		WinSet Style, %Style%, ahk_id %g_hWnd%
		WinSet Redraw,, ahk_id %g_hWnd%
	} else if (nTab == 2) {
		guiControlGet ExStyle,, EdtExStyleSum
		WinSet ExStyle, %ExStyle%, ahk_id %g_hWnd%
	} else if (nTab == 3) {
		guiControlGet ExtraStyle,, EdtExtraStyleSum
		WinGetClass Class, ahk_id %g_hWnd%
		switch Class {
			case "SysListView32"	: _msg:= "0x1036"
			case "SysTreeView32"	: _msg:= "0x112C"
			case "SysTabControl32"	: _msg:= "0x1334"
			case "ToolbarWindow32"	: _msg:= "0x0454"
			case "ComboBox"			: _msg:= "0x040E"
		}
		sendmessage,% _msg, 0, %ExtraStyle%,,ahk_id %g_hWnd%	; CBEM_SETEXTENDEDSTYLE
		((errorlevel="Fail")? msgb0x(ErrorLevel,5))
	}

	; 0x17: SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE
	DllCall("SetWindowPos", "Ptr", g_hWnd, "UInt", 0, "Int", 0, "Int", 0, "Int", 0, "Int", 0, "UInt", 0x17)
	WinSet Redraw,, ahk_id %g_hWnd%
return,

ResetStyle:
	nTab:= DllCall("SendMessage", "Ptr", hStylesTab, "UInt", 0x130B, "UInt", 0, "UInt", 0) + 1
	if (nTab == 1) {
		guiControl, Spy:, EdtStyleSum, %g_Style%
	} else if (nTab == 2) {
		guiControl, Spy:, EdtExStyleSum, %g_ExStyle%
	} else if (nTab == 3) {
		guiControl, Spy:, EdtExtraStyleSum, %g_ExtraStyle%
	}

	GoSub LoadStyles
return,

GetExtraStyle(hWnd) {
	WinGetClass Class, ahk_id %hWnd%

	if (Class == "SysListView32") {
		Message:= 0x1037 ; LVM_GETEXTENDEDLISTVIEWSTYLE
	} else if (Class == "SysTreeView32") {
		Message:= 0x112D ; TVM_GETEXTENDEDSTYLE
	} else if (Class == "SysTabControl32") {
		Message:= 0x1335 ; TCM_GETEXTENDEDSTYLE
	} else if (Class == "ToolbarWindow32") {
		Message:= 0x455 ; TB_GETEXTENDEDSTYLE
	} else if (Class == "ComboBox" && g_Style & 0x10) {
		Message:= 0x409 ; CBEM_GETEXTENDEDSTYLE
	}

	SendMessage %Message%, 0, 0,, ahk_id %hWnd%
	return, Format("0x{:08X}", ErrorLevel)
}

ShowDescription:
	guiControlGet Const,, GrpDesc
	guiControlGet Desc,, TxtDesc

	gui Desc: New, LabelDesc -SysMenu OwnerSpy
	gui Color, black
	gui Margin, 10, 0
	gui Add, CheckBox, x0 y0 w0 h0

	gui Add, Picture, x12 y12 w32 h32 Icon5, user32.dll
	gui Font, s12 c0x003399, Segoe UI
	gui Add, Text, x58 y15 w473 h23 +0x200, %Const%
	gui Font

	gui Font, s10, Segoe UI
	gui Add, Edit, vEdtDesc x55 y55 w444 Multi -VScroll -E0x200, %Desc%
	gui Font

	guicontrolGet Pos, Pos, EdtDesc
	py:= PosY + PosH + 20
	gui Add, Text, hWndhFooter x-1 y%py% w533 h48 -Background

	gui Font, s9, Segoe UI
	gui Add, Button, gDescClose x432 yp+12 w88 h25 Default, &Close

	gui Show, w531, Style Description
return,

DescEscape:
DescClose:
	gui Desc: Destroy
return,

; Messages
LoadMessages:
	WinGetClass Class, ahk_id %g_hWnd%

	Constants:= GetMessages(Class)

	gui Spy: Default
	guiControlGet CurrentItem,, CbxMessages, Text
	guiControl,, CbxMessages, |%Constants%
	guiControl Text, CbxMessages, %CurrentItem%

	; Common Control Messages
	if (Class == "ToolbarWindow32" || Class == "ReBarWindow32") {
		guiControl,, CbxMessages, % GetMessages("CommonControls")
	}

	if (g_WinMsgs == "") {
		g_WinMsgs:= GetMessages("Window")
	}

	guiControl,, CbxMessages, %g_WinMsgs%
return,

GetMessages(Class) {
	Static IniFile:= A_ScriptDir . "\Constants\Messages.ini"

	if (Class == "") {
		return,
	}

	IniRead Section, %IniFile%, %Class%

	Constants:= ""
	Loop Parse, Section, `n
	{
		Constants .= StrSplit(A_LoopField, "=")[1] . "|"
	}

	Sort Constants, D|
	return, Constants
}

SendMsg:
PostMsg:
	gui Spy: Submit, NoHide

	Function:= (A_ThisLabel == "SendMsg") ? "SendMessage" : "PostMessage"

	if CbxMessages is Not Number
	{
		if (SubStr(CbxMessages, 1, 3) == "WM_") {
			ClassName:= "Window"
		} else {
			ClassName:= GetClassName(g_hWnd)
		}

		IniRead Message, %A_ScriptDir%\Constants\Messages.ini, %ClassName%, %CbxMessages%
		if (Message == "ERROR") {
			gui Spy: +OwnDialogs
			MsgBox 0x10, %AppName%, %CbxMessages%: invalid message.
			return,
		}
	} else {
		Message:= CbxMessages
	}

	DataTypes:= {"Number": "UPtr", "String": "WStr"}
	wType:= DataTypes[wParamType]
	lType:= DataTypes[lParamType]

	Result:= DllCall(Function, "Ptr", g_hWnd, "UInt", Message, wType, wParam, lType, lParam)
	guiControl,, Result, %Result%
return,

GoogleSearch:
guiControlGet Message,, CbxMessages

if (Message == "")
	return,
if (SubStr(Message, 1, 3) == "SCI") {
	URL:= "http://www.scintilla.org/ScintillaDoc.html#"
	try	Run %URL%%Message%
} else {
	URL:= googlelucky(Message) ;"https://www.google.com/search?q="
	try	Run %URL%
}
return,

CopyToClipboard:
gui Spy: Default

CRLF:= "`r`n"
Output:= ""

if (Tab == 1) { ; General
	gui Spy: Submit, NoHide
	Output .= "[General]" . CRLF
	Output .= "Handle:`t" . EdtHandle . CRLF
	Output .= "Text:`t" . EdtText . CRLF
	Output .= "Class:`t" . EdtClass . CRLF
	Output .= "ClassNN:`t" . EdtClassNN . CRLF
	Output .= "Style:`t" . EdtStyle . CRLF
	Output .= "Extended:`t" . EdtExStyle . CRLF
	Output .= "Position:`t" . EdtPosition . CRLF
	Output .= "Size:`t" . EdtSize . CRLF
	Output .= "Cursor:`t" . EdtCursor . CRLF
}
else if (Tab == 2) { ; Styles
	if (g_Style) {
		guiControlGet Styles,, %hLbxStyles%
		Output .= "[Styles]" . CRLF . StrReplace(Styles, "|", CRLF) . CRLF . CRLF
	}

	if (g_ExStyle) {
		guiControlGet ExStyles,, %hLbxExStyles%
		Output .= "[ExStyles]" . CRLF . StrReplace(ExStyles, "|", CRLF) . CRLF . CRLF
	}

	if (g_ExtraStyle) {
		guiControlGet ExtraStyles,, %hLbxExtraStyles%
		Output .= "[ExtraStyles]" . CRLF . StrReplace(ExtraStyles, "|", CRLF)
	}
}
else if (Tab == 3) { ; Details
	ControlGet, ClassInfo, List,,, ahk_id %hClassInfo%
	ControlGet, PropInfo, List,,, ahk_id %hPropInfo%
	Output .= "[Details]" . CRLF . ClassInfo . CRLF . CRLF . "[Properties]" . CRLF . PropInfo
}
else if (Tab == 5) { ; Extra
	ControlGet, ExtraInfo, List,,, ahk_id %hExtraInfo%
	Output .= "[Extra]" . CRLF . ExtraInfo
}
else if (Tab == 6) { ; Windows
	ControlGet, Child, List,,, ahk_id %hChildList%
	if (Child != "") {
		Output .= "[Child]" . CRLF . Child . CRLF . CRLF
	}

	ControlGet, Sibling, List,,, ahk_id %hSiblingList%
	if (Sibling != "") {
		Output .= "[Sibling]" . CRLF . Sibling . CRLF . CRLF
	}

	guiControlGet ParentLink,, ParentLink
	Output .= "Parent:`t" . RegExReplace(ParentLink, "\<\/?a\>") . CRLF
	guiControlGet OwnerLink,, OwnerLink
	Output .= "Owner:`t" . RegExReplace(OwnerLink, "\<\/?a\>")
}
else if (Tab == 7) { ; Process
	ControlGet, ProcInfo, List,,, ahk_id %hProcInfo%
	Output .= "[Process]" . CRLF . ProcInfo
}

Clipboard:= RTrim(Output, CRLF)
return,

ControlFromPoint(mx, my, hWnd) {
	hParent:= GetParent(hWnd)
	if (hParent == 0) {
		hParent:= hWnd
	}

	SmallerArea:= 999999999
	hChildWnd:= 0

	WinGet List, ControlListHwnd, ahk_id %hParent% ; EnumChildWindows
	Loop Parse, List, `n
	{
		VarSetCapacity(RECT, 16, 0)
		DllCall("GetWindowRect", "Ptr", A_LoopField, "Ptr", &RECT)
		Left:= NumGet(RECT, 0, "Int")
		Top:= NumGet(RECT, 4, "Int")
		Right:= NumGet(RECT, 8, "Int")
		Bottom:= NumGet(RECT, 12, "Int")

		if ((mx >= Left) && (mx <= Right) && (my >= Top) && (my <= Bottom)) {
			Area:= (Right - Left) * (Bottom - Top)
			if (Area < SmallerArea) {
				SmallerArea:= Area
				hChildWnd:= A_LoopField
			}
		}
	}

	return, (hChildWnd == 0) ? hWnd : hChildWnd
}

; Details tab
LoadProperties:
	gui Spy: ListView, %hPropInfo%
	LV_Delete()

	Callback:= RegisterCallback("PropEnumProcEx", "F")
	DllCall("EnumPropsEx", "Ptr", g_hWnd, "Ptr", Callback, "UInt", lParam:= 0)
return,

PropEnumProcEx(hWnd, lpszString, hData, dwData) {
	Global hPropInfo

	Property:= StrGet(lpszString, "UTF-16")
	if (Property == "") {
		Property:= lpszString . " (Atom)"
	}

	gui Spy: ListView, %hPropInfo%
	LV_Add("", Property, Format("0x{:08X}", hData))

	return, True
}

LoadExtraInfo:
	gui Spy: ListView, %hExtraInfo%

	LV_Delete()
	While (LV_GetText(foo, 0, 1)) {
		LV_DeleteCol(1)
	}

	WinGetClass Class, ahk_id %g_hWnd%

	if (Class == "Edit" || InStr(Class, "RICHEDIT")) {
		LV_InsertCol(1, "169", "Property")
		LV_InsertCol(2, "169", "Value")

		ControlGetText Text,, ahk_id %g_hWnd%
		Length:= StrLen(Text) . " characters"
		ControlGet Lines, LineCount,,, ahk_id %g_hWnd%
		ControlGet CurLine, CurrentLine,,, ahk_id %g_hWnd%
		ControlGet CurCol, CurrentCol,,, ahk_id %g_hWnd%

		LV_Add("", "Length", Length)
		LV_Add("", "Current line", CurLine)
		LV_Add("", "Current column", CurCol)
		LV_Add("", "Line count", Lines)
		LV_Add("", "Text Limit", SendMsg(0xD5) . " bytes") ; EM_GETLIMITTEXT
		LV_Add("", "Modified", {0: "False", 1: "True"}[SendMsg(0xB8)]) ; EM_GETMODIFY
	}
	else if (InStr(Class, "Scintilla")) {

		LV_InsertCol(1, "169", "Property")
		LV_InsertCol(2, "169", "Value")

		LexerName:= Scintilla_GetLexerLanguage(g_hWnd)
		CodePage:= SendMsg(2137) ; SCI_GETCODEPAGE
		Pos:= SendMsg(2008)
		Line:= SendMsg(2166, Pos)
		Char:= SendMsg(2007, Pos)
		Size:= FormatBytes(SendMsg(2006), Sep, "B", 0) . " bytes"
		SelSize:= FormatBytes(SendMsg(2161, 0, 0) - 1, Sep, "B", 0) . " bytes"

		LV_Add("", "Lexer", SendMsg(4002) . (LexerName != "" ? " (" . LexerName . ")" : "")) ; SCI_GETLEXER
		LV_Add("", "Current position", Pos + 1) ; SCI_GETCURRENTPOS
		LV_Add("", "Char at position", Char . " (""" . Chr(Char) . """)") ; SCI_GETCHARAT
		LV_Add("", "Style at position", SendMsg(2010, Pos)) ; SCI_GETSTYLEAT
		LV_Add("", "Current line", Line + 1) ; SCI_LINEFROMPOSITION
		LV_Add("", "Position from line", SendMsg(2167, Line) + 1) ; SCI_POSITIONFROMLINE
		LV_Add("", "Line end position", SendMsg(2136, Line) + 1) ; SCI_GETLINEENDPOSITION
		LV_Add("", "Line length", SendMsg(2350, Line)) ; SCI_LINELENGTH
		LV_Add("", "Current column", SendMsg(2129, Pos) + 1) ; SCI_GETCOLUMN
		LV_Add("", "Line count", SendMsg(2154)) ; SCI_GETLINECOUNT
		LV_Add("", "Document size", Size) ; SCI_GETLENGTH
		LV_Add("", "File encoding", (CodePage == 65001 ? "UTF-8 (65001)" : CodePage)) ; SCI_GETCODEPAGE
		LV_Add("", "Modified", SendMsg(2159) ? "True" : "False") ; SCI_GETMODIFY
		LV_Add("", "Read only", SendMsg(2140) ? "True" : "False") ; SCI_GETREADONLY
		LV_Add("", "Wrap mode", SendMsg(2269)) ; SCI_GETWRAPMODE
		LV_Add("", "Tab width", SendMsg(2121)) ; SCI_GETTABWIDTH
		LV_Add("", "Indent with spaces", !SendMsg(2125) ? "True" : "False") ; SCI_GETUSETABS
		LV_Add("", "Show indentation guides", SendMsg(2133) ? "True" : "False") ; SCI_GETINDENTATIONguiDES
		LV_Add("", "EOL mode", {0: "CRLF", 1: "CR", 2: "LF"}[SendMsg(2030)]) ; SCI_GETEOLMODE
		LV_Add("", "Paste convert EOL", SendMsg(2468) ? "True" : "False") ; SCI_GETPASTECONVERTENDINGS
		LV_Add("", "Overtype mode", SendMsg(2187) ? "1 (overtype)" : "0 (insert)") ; SCI_GETOVERTYPE
		LV_Add("", "Anchor position", SendMsg(2009) + 1) ; SCI_GETANCHOR
		LV_Add("", "Selection start", SendMsg(2143) + 1) ; SCI_GETSELECTIONSTART
		LV_Add("", "Selection end", SendMsg(2145) + 1) ; SCI_GETSELECTIONEND
		LV_Add("", "Selected text length", SelSize) ; SCI_GETSELTEXT
		LV_Add("", "Selection mode", SendMsg(2423)) ; SCI_GETSELECTIONMODE
		LV_Add("", "Selection is rectangular", SendMsg(2372) ? "True" : "False") ; SCI_SELECTIONISRECTANGLE
		LV_Add("", "Virtual space options", SendMsg(2597)) ; SCI_GETVIRTUALSPACEOPTIONS
		LV_Add("", "Rectangular selection modifier", SendMsg(2599)) ; SCI_GETRECTANGULARSELECTIONMODIFIER
		; SCI_GETMOUSESELECTIONRECTANGULARSWITCH
		LV_Add("", "Mouse rectangular selection", SendMsg(2669) ? "True" : "False")
		LV_Add("", "Selection start line position", SendMsg(2424, Line) + 1) ; SCI_GETLINESELSTARTPOSITION
		LV_Add("", "Selection end line position", SendMsg(2425, Line) + 1) ; SCI_GETLINESELENDPOSITION
		LV_Add("", "Multiple selection", SendMsg(2564) ? "True" : "False") ; SCI_GETMULTIPLESELECTION
		; SCI_GETADDITIONALSELECTIONTYPING
		LV_Add("", "Additional selection typing", SendMsg(2566) ? "True" : "False")
		LV_Add("", "Multipaste", SendMsg(2615)) ; SCI_GETMULTIPASTE
		LV_Add("", "Line height", SendMsg(2279, Line)) ; SCI_TEXTHEIGHT
		LV_Add("", "Baseline extra ascent", SendMsg(2526)) ; SCI_GETEXTRAASCENT
		LV_Add("", "Baseline extra descent", SendMsg(2528)) ; SCI_GETEXTRADESCENT
		LV_Add("", "Lines on screen", SendMsg(2370)) ; SCI_LINESONSCREEN
		LV_Add("", "First visible line", SendMsg(2152) + 1) ; SCI_GETFIRSTVISIBLELINE
		LV_Add("", "Current line wrap count", SendMsg(2235, Line)) ; SCI_WRAPCOUNT
		LV_Add("", "Mouse hover time", SendMsg(2265)) ; SCI_GETMOUSEDWELLTIME
		LV_Add("", "Word start position", SendMsg(2266, Pos, 1) + 1) ; SCI_WORDSTARTPOSITION
		LV_Add("", "Word end position", SendMsg(2267, Pos, 1) + 1) ; SCI_WORDENDPOSITION
		LV_Add("", "Autocomplete ignore case", SendMsg(2116) ? "True" : "False") ; SCI_AUTOCGETIGNORECASE
		LV_Add("", "Autocomplete list presorted", SendMsg(2661)) ; SCI_AUTOCGETORDER
		LV_Add("", "Autocomplete list max rows", SendMsg(2211)) ; SCI_AUTOCGETMAXHEIGHT
		LV_Add("", "Position before", SendMsg(2417, Pos) + 1) ; SCI_POSITIONBEFORE
		LV_Add("", "Position after", SendMsg(2418, Pos) + 1) ; SCI_POSITIONAFTER
		LV_Add("", "Current indicator", SendMsg(2501)) ; SCI_GETINDICATORCURRENT
		LV_Add("", "Target start", SendMsg(2191) + 1) ; SCI_GETTARGETSTART
		LV_Add("", "Target end", SendMsg(2193) + 1) ; SCI_GETTARGETEND
		LV_Add("", "Search flags", SendMsg(2199)) ; SCI_GETSEARCHFLAGS
		LV_Add("", "Error status", SendMsg(2383)) ; SCI_GETSTATUS
		LV_Add("", "Font quality", SendMsg(2612)) ; SCI_GETFONTQUALITY
		LV_Add("", "Technology (drawing API)", SendMsg(2631)) ; SCI_GETTECHNOLOGY
		LV_Add("", "Buffered drawing", SendMsg(2034) ? "True" : "False") ; SCI_GETBUFFEREDDRAW
		LV_Add("", "Zoom factor", SendMsg(2374)) ; SCI_GETZOOM
		LV_Add("", "Edge mode", SendMsg(2362)) ; SCI_GETEDGEMODE 
		LV_Add("", "Edge column", SendMsg(2360) + 1) ; SCI_GETEDGECOLUMN
		LV_Add("", "Scroll width", SendMsg(2275)) ; SCI_GETSCROLLWIDTH
		LV_Add("", "Scroll width tracking", SendMsg(2517) ? "True" : "False") ; SCI_GETSCROLLWIDTHTRACKING
		LV_Add("", "End at last line", SendMsg(2278) ? "True" : "False") ; SCI_GETENDATLASTLINE
		LV_Add("", "View white space", SendMsg(2020)) ; SCI_GETVIEWWS
		LV_Add("", "White space size", SendMsg(2087)) ; SCI_GETWHITESPACESIZE
		LV_Add("", "View EOL characters", SendMsg(2355) ? "True" : "False") ; SCI_GETVIEWEOL
		LV_Add("", "Caret width", SendMsg(2189)) ; SCI_GETCARETWIDTH
		LV_Add("", "Caret blinking rate", SendMsg(2075) . " ms") ; SCI_GETCARETPERIOD
		LV_Add("", "Markers in current line", SendMsg(2046, Line)) ; SCI_MARKERGET
		LV_Add("", "Automatic fold", SendMsg(2664)) ; SCI_GETAUTOMATICFOLD
		LV_Add("", "All lines visible", SendMsg(2236) ? "True" : "False") ; SCI_GETALLLINESVISIBLE
		;LV_Add("", "", SendMsg()) ;

		Loop 5 { ; The maximum number of margins
			i:= A_Index - 1
			LV_Add("", "Margin " . A_Index . " - type, width, mask"
			, SendMsg(2241, i) . ", " . SendMsg(2243, i) . ", " . SendMsg(2245, i))
			; SCI_GETMARGINTYPEN, SCI_GETMARGINWIDTHN, SCI_GETMARGINMASKN
		}

	}
	else if (Class == "ToolbarWindow32") {

		LV_InsertCol(1, "41", "Index")
		LV_InsertCol(2, "85", "Command ID")
		LV_InsertCol(3, "212", "Button Text")

		Items:= GetToolbarItems(g_hWnd)
		For Each, Item in Items {
			LV_Add("", A_Index, Item.ID, Item.String)
		}
	}
	else if (Class == "SysHeader32") {

		LV_InsertCol(1, "42", "Index")
		LV_InsertCol(2, "48", "Width")
		LV_InsertCol(3, "248", "Text")

		Items:= GetHeaderInfo(g_hWnd)
		For Each, Item in Items {
			LV_Add("", A_Index, Item.Width, Item.Text)
		}
	}
	else if (Class == "msctls_progress32") {

		LV_InsertCol(1, "169", "Property")
		LV_InsertCol(2, "169", "Value")

		LV_Add("", "Range", SendMsg(0x407, 1) . " - " . SendMsg(0x407, 0)) ; PBM_GETRANGE
		LV_Add("", "Position", SendMsg(0x408)) ; PBM_GETPOS
		LV_Add("", "Step increment", SendMsg(0x40D)) ; PBM_GETSTEP
		LV_Add("", "State", {1: "Normal", 2: "Error", 3: "Paused"}[SendMsg(0x411)]) ; PBM_GETSTATE
	}
	else if (Class ~= "ListBox" || Class ~= "ComboBox") {

		LV_InsertCol(1, "38", "Line")
		LV_InsertCol(2, "300", "Text")

		ControlGet ItemList, List,,, ahk_id %g_hWnd%
		Loop Parse, ItemList, `n
		{
			LV_Add("", A_Index, A_LoopField)
		}
	}
	else if (Class == "msctls_statusbar32") {

		LV_InsertCol(1, "38", "Part")
		LV_InsertCol(2, "300", "Text")

		SB_Text:= GetStatusBarText(g_hWnd)
		Loop Parse, SB_Text, |
		{
			LV_Add("", A_Index, A_LoopField)
		}
	}
	else if (Class == "SysTabControl32") {

		LV_InsertCol(1, "42", "Index")
		LV_InsertCol(2, "296", "Text")

		Tabs:= ControlGetTabs(g_hWnd)
		Loop % Tabs.Length() {
			LV_Add("", A_Index, Tabs[A_Index])
		}
	}
	else if (Class == "SysListView32") {

		SendMessage 0x101F, 0, 0,, ahk_id %g_hWnd% ; LVM_GETHEADER
		hHeader:= ErrorLevel
		SendMessage 0x1200, 0, 0,, ahk_id %hHeader% ; HDM_GETITEMCOUNT
		Columns:= ErrorLevel + 1

		Loop %Columns% {
			ColTitle:= A_Index == 1 ? "Index" : "Column " . A_Index - 1
			LV_InsertCol(A_Index, "", ColTitle)
		}

		ControlGet ItemList, List,,, ahk_id %g_hWnd%
		Loop Parse, ItemList, `n
		{
			Items:= StrSplit(A_LoopField, A_Tab)
			LV_Add("", A_Index, Items*)
		}

		Loop %Columns% {
			LV_ModifyCol(A_Index, "AutoHdr")
		}
	}

	; GetMenu return, value: if the window is a child window, the return, value is undefined.
	if (!IsChild(g_hWnd) && hMenu:= GetMenu(g_hWnd)) {
		guiControl Enable, %hBtnMenu%
	} else {
		guiControl Disable, %hBtnMenu%
	}
return,

SendMsg(Message, wParam:= 0, lParam:= 0) {
	SendMessage %Message%, %wParam%, %lParam%,, ahk_id %g_hWnd%
	return, ErrorLevel
}

Screenshot:
	if (!WinExist("ahk_id" . g_hWnd)) {
		gui Spy: +OwnDialogs
		MsgBox 0x40010, Error, Window no longer exists.
		return,
	}

	if (IsChild(g_hWnd)) {
		WinActivate % "ahk_id" . GetAncestor(g_hWnd)
		Sleep 100
		if (g_ShowBorder) {
			ShowBorder(g_hWnd, -1, g_BorderColor, g_BorderWidth)
			Sleep 100
			Send !{PrintScreen}
			Sleep 200
		} else {
			CaptureWindow(hSpyWnd, g_hWnd)
		}
	} else {
		WinActivate ahk_id %g_hWnd%
		Sleep 100
		Send !{PrintScreen}
	}

	Loop 4 {
		Index:= A_Index + 90
		gui %Index%: Destroy
	}

	WinActivate ahk_id %hSpyWnd%
	gui Spy: +OwnDialogs
	MsgBox 0x40040, %AppName%, Content copied to the clipboard.
return,

CaptureWindow(hwndOwner, hwnd) {
	VarSetCapacity(RECT, 16, 0)
	DllCall("GetWindowRect", "Ptr", hwnd, "Ptr", &RECT)
	width := NumGet(RECT, 8, "Int")  - NumGet(RECT, 0, "Int")
	height:= NumGet(RECT, 12, "Int") - NumGet(RECT, 4, "Int")

	hdc   := DllCall("GetDC", "Ptr", 0, "Ptr")
	hdcMem:= DllCall("CreateCompatibleDC", "Ptr", hdc, "UPtr")
	hBmp  := DllCall("CreateCompatibleBitmap", "Ptr", hdc, "Int", width, "Int", height, "UPtr")
	hdcOld:= DllCall("SelectObject", "Ptr", hdcMem, "Ptr", hBmp)

	DllCall("BitBlt", "Ptr", hdcMem
		, "Int", 0, "Int", 0, "Int", width, "Int", height
		, "Ptr", hdc, "Int", Numget(RECT, 0, "Int"), "Int", Numget(RECT, 4, "Int")
		, "UInt", 0x00CC0020) ; SRCCOPY

	DllCall("SelectObject", "Ptr", hdcMem, "Ptr", hdcOld)

	DllCall("OpenClipboard", "Ptr", hwndOwner) ; Clipboard owner
	DllCall("EmptyClipboard")
	DllCall("SetClipboardData", "UInt", 0x2, "Ptr", hBmp) ; CF_BITMAP
	DllCall("CloseClipboard")

	DllCall("ReleaseDC", "Ptr", 0, "Ptr", hdc)

	return, True
}

GetToolbarItems(hToolbar) {
	WinGet PID, PID, ahk_id %hToolbar%

	if !(hProc:= DllCall("OpenProcess", "UInt", 0x438, "Int", False, "UInt", PID, "Ptr")) {
		return,
	}

	if (A_Is64bitOS) {
		Try DllCall("IsWow64Process", "Ptr", hProc, "Int*", Is32bit:= true)
	} else {
		Is32bit:= True
	}

	RPtrSize:= Is32bit ? 4 : 8
	TBBUTTON_SIZE:= 8 + (RPtrSize * 3)

	SendMessage 0x418, 0, 0,, ahk_id %hToolbar% ; TB_BUTTONCOUNT
	ButtonCount:= ErrorLevel

	IDs:= [] ; Command IDs
	Loop %ButtonCount% {
		Address:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0, "UPtr", TBBUTTON_SIZE, "UInt", 0x1000, "UInt", 4, "Ptr")

		SendMessage 0x417, % A_Index - 1, Address,, ahk_id %hToolbar% ; TB_GETBUTTON
		if (ErrorLevel == 1) {
			VarSetCapacity(TBBUTTON, TBBUTTON_SIZE, 0)
			DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", Address, "Ptr", &TBBUTTON, "UPtr", TBBUTTON_SIZE, "Ptr", 0)
			IDs.Push(NumGet(&TBBUTTON, 4, "Int"))
		}

		DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", Address, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	}

	ToolbarItems:= []
	Loop % IDs.Length() {
		ButtonID:= IDs[A_Index]
		;SendMessage 0x44B, %ButtonID% , 0,, ahk_id %hToolbar% ; TB_GETBUTTONTEXTW
		;BufferSize:= ErrorLevel * 2
		BufferSize:= 128

		Address:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0, "UPtr", BufferSize, "UInt", 0x1000, "UInt", 4, "Ptr")

		SendMessage 0x44B, %ButtonID%, Address,, ahk_id %hToolbar% ; TB_GETBUTTONTEXTW

		VarSetCapacity(Buffer, BufferSize, 0)
		DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", Address, "Ptr", &Buffer, "UPtr", BufferSize, "Ptr", 0)

		ToolbarItems.Push({"ID": IDs[A_Index], "String": Buffer})

		DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", Address, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	}

	DllCall("CloseHandle", "Ptr", hProc)

	return, ToolbarItems
}

LoadWindowsTab:
	GoSub LoadChildList
	GoSub LoadSiblingList

	hParent:= GetParent(g_hWnd)
	ParentClass:= (hParent) ? " (" GetClassName(hParent) . ")" : ""
	ParentLink:= "<a>" . Format("0x{:08X}", hParent) . "</a>" . ParentClass
	guiControl, Spy:, ParentLink, %ParentLink%

	hOwner:= GetOwner(g_hWnd)
	OwnerClass:= (hOwner) ? " (" GetClassName(hOwner) . ")" : ""
	OwnerLink:= "<a>" . Format("0x{:08X}", hOwner) . "</a>" . OwnerClass
	guiControl, Spy:, OwnerLink, %OwnerLink%
return,

LinkToHandle:
	guiControlGet LinkText, Spy:, %A_guiControl%
	if (RegExMatch(LinkText, "(0x\w+)", Match)) {
		ShowWindowInfoIfExist(Match)
	}
return,

WindowsTabHandler:
	if (A_guiEvent == "N") {
		Code:= NumGet(A_EventInfo + 0, A_PtrSize * 2, "Int")
		if (Code == -551) { ; TCN_SELCHANGE
			SendMessage 0x130B, 0, 0,, ahk_id %hWindowsTab% ; TCM_GETCURSEL
			nTab:= Errorlevel + 1

			if (nTab == 1) {
				guiControl Hide, %hSiblingList%
				guiControl Show, %hChildList%
			} else {
				guiControl Hide, %hChildList%
				guiControl Show, %hSiblingList%
			}
		}
	}
return,

LoadChildList:
	gui Spy: ListView, %hChildList%
	LV_Delete()

	WinGet ChildList, ControlListHwnd, ahk_id %g_hWnd%
	Loop Parse, ChildList, `n
	{
		if (GetParent(A_LoopField) != g_hWnd) {
			Continue
		}

		WinGetClass Class, ahk_id %A_LoopField%
		ControlGetText Text,, ahk_id %A_LoopField%
		LV_Add("", Format("0x{:08X}", A_LoopField), Class, Text)
	}
return,

LoadSiblingList:
	gui Spy: ListView, %hSiblingList%
	LV_Delete()

	hParent:= GetParent(g_hWnd)

	if (IsChild(g_hWnd)) {
		WinGet SiblingList, ControlListHwnd, ahk_id %hParent%
		Loop Parse, SiblingList, `n
		{
			if (A_LoopField == g_hWnd) {
				Continue
			}

			if (GetParent(A_LoopField) != hParent) {
				Continue
			}

			WinGetClass Class, ahk_id %A_LoopField%
			ControlGetText Text,, ahk_id %A_LoopField%
			LV_Add("", Format("0x{:08X}", A_LoopField), Class, Text)
		}

	} else {
		WinGet WinList, List, % (hParent == 0) ? "" : "ahk_id " . hParent
		Loop %WinList% {
			hWnd:= WinList%A_Index%

			if (hWnd == g_hWnd) {
				Continue
			}

			WinGetClass Class, ahk_id %hWnd%
			WinGetTitle Text, ahk_id %hWnd%
			LV_Add("", Format("0x{:08X}", hWnd), Class, Text)
		}
	}
return,

ChildListHandler:
SiblingListHandler:
	gui Spy: ListView, % (A_ThisLabel == "ChildListHandler") ? hChildList : hSiblingList
	if (A_guiEvent != "ColClick") {
		LV_GetText(hWnd, LV_GetNext())
		ShowWindowInfoIfExist(hWnd)
	}
return,
; OnWM_KEYDOWN(wParam, lParam, msg, hWnd) {
	; Global

	; if (wParam == 112) { ; F1
		; GoSub ShowHelp

	; } else if (wParam == 113) { ; F2
		; if (hParent:= GetParent(g_hWnd)) {
			; g_hWnd:= hParent
			; ShowWindowInfo()
		; }

	; } else if (wParam == 114) { ; F3
		; GoSub ShowFindDlg

	; } else if (wParam == 115) { ; F4
		; GoSub ShowTree

	; } else if (wParam == 116) { ; F5
		; if (WinActive("ahk_id" . hTreeWnd)) {
			; return,
		; }

		; gui Spy: Submit, NoHide
		; ShowWindowInfoIfExist(EdtHandle)

	; } else if (wParam == 117) { ; F6
		; GoSub FlashWindow

	; } else if (wParam == 118) { ; F7
		; GoSub ShowXYWHDlg

	; } else if (wParam == 119) { ; F8
		; GoSub CopyToClipboard

	; } else if (wParam == 120) { ; F9
		; GoSub Screenshot
	; }
; }
OnWM_KEYDOWN(wParam, lParam, msg, hWnd) {
	Global
	static wmkeynit:=OnMessage(0x100, "OnWM_KEYDOWN")
	switch wParam {
	case "112":									   ;F1
		GoSub ShowHelp								
	case "113":									   ;F2
		if (hParent:= GetParent(g_hWnd)) {			
			g_hWnd:= hParent						  
			ShowWindowInfo()						  
		}											 
	case "114":									   ;F3
		GoSub ShowFindDlg							 
	case "115":									   ;F4
		GoSub ShowTree								
	case "116":									   ;F5
		If(WinActive("ahk_id" . hTreeWnd))		 
			return,									
		gui Spy: Submit, NoHide					   
		ShowWindowInfoIfExist(EdtHandle)			  
	case "117":									   ;F6
		GoSub FlashWindow							 
	case "118":									   ;F7
		GoSub ShowXYWHDlg
	case "119":									   ;F8
		GoSub CopyToClipboard
	case "120":									   ;F9
		GoSub Screenshot
}	}

UpdateTitleBar:
	WinGetClass Class, ahk_id %g_hWnd%
	hWnd:= Format("0x{:X}", g_hWnd)
	WinSetTitle ahk_id %hSpyWnd%,, %AppName% [%hWnd%`, %Class%]
return,

; https://autohotkey.com/board/topic/70727-ahk-l-controlgettabs/
ControlGetTabs(hTab) {
	Static MAX_TEXT_LENGTH:= 260
		 , MAX_TEXT_SIZE:= MAX_TEXT_LENGTH * (A_IsUnicode ? 2 : 1)

	WinGet PID, PID, ahk_id %hTab%

	; Open the process for read/write and query info.
	; PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION
	if !(hProc:= DllCall("OpenProcess", "UInt", 0x438, "Int", False, "UInt", PID, "Ptr")) {
		return,
	}

	; Should we use the 32-bit struct or the 64-bit struct?
	if (A_Is64bitOS) {
		Try DllCall("IsWow64Process", "Ptr", hProc, "Int*", Is32bit:= true)
	} else {
		Is32bit:= True
	}

	RPtrSize:= Is32bit ? 4 : 8
	TCITEM_SIZE:= 16 + RPtrSize * 3

	; Allocate a buffer in the (presumably) remote process.
	remote_item:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0
						 , "uPtr", TCITEM_SIZE + MAX_TEXT_SIZE
						 , "UInt", 0x1000, "UInt", 4, "Ptr") ; MEM_COMMIT, PAGE_READWRITE
	remote_text:= remote_item + TCITEM_SIZE

	; Prepare the TCITEM structure locally.
	VarSetCapacity(TCITEM, TCITEM_SIZE, 0)
	NumPut(1, TCITEM, 0, "UInt") ; mask (TCIF_TEXT)
	NumPut(remote_text, TCITEM, 8 + RPtrSize) ; pszText
	NumPut(MAX_TEXT_LENGTH, TCITEM, 8 + RPtrSize * 2, "Int") ; cchTextMax

	; Write the local structure into the remote buffer.
	DllCall("WriteProcessMemory", "Ptr", hProc, "Ptr", remote_item, "Ptr", &TCITEM, "UPtr", TCITEM_SIZE, "Ptr", 0)

	Tabs:= []
	VarSetCapacity(TabText, MAX_TEXT_SIZE)

	SendMessage 0x1304, 0, 0,, ahk_id %hTab% ; TCM_GETITEMCOUNT
	Loop % (ErrorLevel != "FAIL") ? ErrorLevel : 0 {
		; Retrieve the item text.
		SendMessage, % (A_IsUnicode) ? 0x133C : 0x1305, A_Index - 1, remote_item,, ahk_id %hTab% ; TCM_GETITEM
		if (ErrorLevel == 1) { ; Success
			DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", remote_text, "Ptr", &TabText, "UPtr", MAX_TEXT_SIZE, "Ptr", 0)
		} else {
			TabText:= ""
		}

		Tabs[A_Index]:= TabText
	}

	; Release the remote memory and handle.
	DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", remote_item, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	DllCall("CloseHandle", "Ptr", hProc)

	return, Tabs
}

SetDHW:
	g_DetectHidden:= !g_DetectHidden
return,

SetMinimize:
	g_Minimize:= !g_Minimize
return,

SetExplorerTheme(hWnd) {
	DllCall("UxTheme.dll\SetWindowTheme", "Ptr", hWnd, "WStr", "Explorer", "Ptr", 0)
}

SetButtonIcon(hButton, File, Index:= 1) {
	himl:= DllCall("ImageList_Create", "Int", 16, "Int", 16, "UInt", 0x20, "Int", 1, "Int", 1, "Ptr") ; ILC_COLOR32
	IL_Add(himl, File, Index)
	VarSetCapacity(BUTTON_IMAGELIST, 20 + A_PtrSize, 0)
	NumPut(himl, BUTTON_IMAGELIST, 0, "Ptr")
	NumPut(4, BUTTON_IMAGELIST, 16 + A_PtrSize, "UInt") ; Alignment (BUTTON_IMAGELIST_ALIGN_CENTER)
	SendMessage 0x1602, 0, &BUTTON_IMAGELIST,, ahk_id %hButton% ; BCM_SETIMAGELIST
	return, ErrorLevel
}

ShowXYWHDlg:
	gui XYWH: New, LabelXYWH
	gui Font, s9, Segoe UI
	gui Color, black

	gui Add, GroupBox, x10 y6 w145 h105, Relative to:
	gui Add, Radio, vClientCoords gSetXYWH x25 y27 w120 h23 +Checked, Client area
	gui Add, Radio, vWindowCoords gSetXYWH x25 y51 w120 h23, Window border
	gui Add, Radio, vScreenCoords gSetXYWH x25 y75 w120 h23, Screen coords

	gui Add, GroupBox, x166 y5 w253 h105
	gui Add, Text, x182 y31 w26 h23 +0x200, X:
	gui Add, Edit, vEdtX x209 y31 w70 h21
	gui Add, UpDown, gMoveWindow Range-64000-64000 +0x80
	gui Add, Text, x303 y31 w26 h23 +0x200, Y:
	gui Add, Edit, vEdtY x330 y31 w70 h21
	gui Add, UpDown, gMoveWindow Range-64000-64000 +0x80
	gui Add, Text, x182 y69 w26 h23 +0x200, W:
	gui Add, Edit, vEdtW x209 y69 w70 h21
	gui Add, UpDown, gMoveWindow Range-64000-64000 +0x80
	gui Add, Text, x303 y69 w26 h23 +0x200, H:
	gui Add, Edit, vEdtH x330 y69 w70 h21
	gui Add, UpDown, gMoveWindow Range-64000-64000 +0x80

	gui Add, Text, x-1 y121 w460 h49 +0x200 -Background +Border
	gui Add, Button, gResetXYWH x9 y133 w88 h25, &Reset
	gui Add, Button, gMoveWindow x235 y133 w88 h25 +Default, &Apply
	gui Add, Button, gXYWHClose x331 y133 w88 h25, &Close

	gui Show, w429 h170, Position and Size

	g_NewXYWH:= True
	GoSub SetXYWH

	if (IsChild(g_hWnd)) {
		guiControl Enable, ClientCoords
		guiControl Enable, WindowCoords
		guiControl Enable, ScreenCoords
	} else {
		guiControl Disable, ClientCoords
		guiControl Disable, WindowCoords
		guiControl Disable, ScreenCoords
		guiControl,, ScreenCoords, 1
	}
return,

XYWHEscape:
XYWHClose:
	gui XYWH: Destroy
return,

SetXYWH:
	gui XYWH: Submit, NoHide

	if (IsChild(g_hWnd)) {
		if (ClientCoords) {
			GetWindowPos(g_hWnd, X, Y, W, H)
		} else if (WindowCoords) {
			ControlGetPos X, Y, W, H,, ahk_id %g_hWnd%
		} else if (ScreenCoords) {
			WinGetPos X, Y, W, H, ahk_id %g_hWnd%
		}
	} else { ; Top-level window
		WinGetPos X, Y, W, H, ahk_id %g_hWnd%
	}

	guiControl, XYWH:, EdtX, %X%
	guiControl, XYWH:, EdtY, %Y%
	guiControl, XYWH:, EdtW, %W%
	guiControl, XYWH:, EdtH, %H%

	if (g_NewXYWH) {
		g_BackupXYWH:= [X, Y, W, H]
		g_NewXYWH:= False
	}
return,

MoveWindow:
	gui XYWH: Submit, NoHide

	if (IsChild(g_hWnd)) {

		if (ClientCoords) {
			SetWindowPos(g_hWnd, EdtX, EdtY, EdtW, EdtH, 0, 0x14) ; SWP_NOACTIVATE | SWP_NOZORDER
		} else if (WindowCoords) {
			ControlMove,, %EdtX%, %EdtY%, %EdtW%, %EdtH%, ahk_id %g_hWnd%
		} else if (ScreenCoords) {
			VarSetCapacity(POINT, 8, 0)
			NumPut(EdtX, POINT, 0)
			NumPut(EdtY, POINT, 4)
			DllCall("ScreenToClient", "Ptr", GetParent(g_hWnd), "Ptr", &POINT) ; PARENT
			X:= NumGet(POINT, 0)
			Y:= NumGet(POINT, 4)
			SetWindowPos(g_hWnd, X, Y, EdtW, EdtH, 0, 0x14) ; SWP_NOACTIVATE | SWP_NOZORDER
		}
	} else {
		WinMove ahk_id %g_hWnd%,, %EdtX%, %EdtY%, %EdtW%, %EdtH%
	}

	WinSet Redraw,, ahk_id %g_hWnd%
return,

ResetXYWH:
	gui XYWH: Submit, NoHide

	if (IsChild(g_hWnd)) {
		guiControl, XYWH:, ClientCoords, 1
	}

	guiControl,, EdtX, % g_BackupXYWH[1]
	guiControl,, EdtY, % g_BackupXYWH[2]
	guiControl,, EdtW, % g_BackupXYWH[3]
	guiControl,, EdtH, % g_BackupXYWH[4]
	GoSub MoveWindow
return,

OnWM_RBUTTONDOWN(wParam, lParam, msg, hWnd) {
	Global
	if (hWnd == hLbxStyles || hWnd == hLbxExStyles || hWnd == hLbxExtraStyles) {
		SendMessage 0x1A9, 0, lParam,, ahk_id %hWnd% ; LB_ITEMFROMPOINT
		Index:= ErrorLevel
		SendMessage 0x18A, %Index%, 0,, ahk_id %hWnd% ; LB_GETTEXTLEN
		Len:= ErrorLevel
		VarSetCapacity(LB_Text, Len << !!A_IsUnicode, 0)
		SendMessage 0x189, %Index%, % &LB_Text,, ahk_id %hWnd% ; LB_GETTEXT
		Const:= StrSplit(StrGet(&LB_Text, Len), "`t")[1]
		Desc:= StrReplace(oStyles[Const].Desc, "\n", "`n")
		guiControl,, GrpDesc, %Const%
		guiControl,, TxtDesc, %Desc%
	}
}

ShowWindowInfoIfExist(hWnd) {
	if (IsWindow(hWnd)) {
		g_hWnd:= hWnd
		ShowWindowInfo()
	} else {
		gui Spy: +OwnDialogs
		MsgBox 0x40010, %AppName%, Invalid window handle.
	}
}

; return,s an object containing the text and width of each item of a remote SysHeader32 control
GetHeaderInfo(hHeader) {
	Static MAX_TEXT_LENGTH:= 260
		 , MAX_TEXT_SIZE:= MAX_TEXT_LENGTH * (A_IsUnicode ? 2 : 1)

	WinGet PID, PID, ahk_id %hHeader%

	; Open the process for read/write and query info.
	; PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION
	if !(hProc:= DllCall("OpenProcess", "UInt", 0x438, "Int", False, "UInt", PID, "Ptr")) {
		return,
	}

	; Should we use the 32-bit struct or the 64-bit struct?
	if (A_Is64bitOS) {
		Try DllCall("IsWow64Process", "Ptr", hProc, "Int*", Is32bit:= True)
	} else {
		Is32bit:= True
	}

	RPtrSize:= Is32bit ? 4 : 8
	cbHDITEM:= (4 * 6) + (RPtrSize * 6)

	; Allocate a buffer in the remote process.
	remote_item:= DllCall("VirtualAllocEx", "Ptr", hProc, "Ptr", 0
						 , "UPtr", cbHDITEM + MAX_TEXT_SIZE
						 , "UInt", 0x1000, "UInt", 4, "Ptr") ; MEM_COMMIT, PAGE_READWRITE
	remote_text:= remote_item + cbHDITEM

	; Prepare the HDITEM structure locally.
	VarSetCapacity(HDITEM, cbHDITEM, 0)
	NumPut(0x3, HDITEM, 0, "UInt") ; mask (HDI_WIDTH | HDI_TEXT)
	NumPut(remote_text, HDITEM, 8, "Ptr") ; pszText
	NumPut(MAX_TEXT_LENGTH, HDITEM, 8 + RPtrSize * 2, "Int") ; cchTextMax

	; Write the local structure into the remote buffer.
	DllCall("WriteProcessMemory", "Ptr", hProc, "Ptr", remote_item, "Ptr", &HDITEM, "UPtr", cbHDITEM, "Ptr", 0)

	HDInfo:= {}
	VarSetCapacity(HDText, MAX_TEXT_SIZE)

	SendMessage 0x1200, 0, 0,, ahk_id %hHeader% ; HDM_GETITEMCOUNT
	Loop % (ErrorLevel != "FAIL") ? ErrorLevel : 0 {
		; Retrieve the item text.
		SendMessage, % (A_IsUnicode) ? 0x120B : 0x1203, A_Index - 1, remote_item,, ahk_id %hHeader% ; HDM_GETITEMW
		if (ErrorLevel == 1) { ; Success
			DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", remote_item, "Ptr", &HDITEM, "UPtr", cbHDITEM, "Ptr", 0)
			DllCall("ReadProcessMemory", "Ptr", hProc, "Ptr", remote_text, "Ptr", &HDText, "UPtr", MAX_TEXT_SIZE, "Ptr", 0)
		} else {
			HDText:= ""
		}

		HDInfo.Push({"Width": NumGet(HDITEM, 4, "UInt"), "Text": HDText})
	}

	; Release the remote memory and handle.
	DllCall("VirtualFreeEx", "Ptr", hProc, "Ptr", remote_item, "UPtr", 0, "UInt", 0x8000) ; MEM_RELEASE
	DllCall("CloseHandle", "Ptr", hProc)

	return, HDInfo
}

SetMouseCoordMode:
	guiControlGet g_MouseCoordMode, Spy:, MouseCoordMode
return,

GetClientCoords(hWnd, ByRef x, ByRef y) {
	VarSetCapacity(POINT, 8, 0)
	NumPut(x, POINT, 0, "Int")
	NumPut(y, POINT, 4, "Int")
	hParent:= GetParent(hWnd)
	DllCall("ScreenToClient", "Ptr", (hParent == 0 ? hWnd : hParent), "Ptr", &POINT)
	x:= NumGet(POINT, 0, "Int")
	y:= NumGet(POINT, 4, "Int")
}

GetWindowCoords(hWnd, ByRef x, ByRef y) {
	hParent:= GetParent(hWnd)
	WinGetPos px, py,,, % "ahk_id" . (hParent == 0 ? hWnd : hParent)
	x:= x - px
	y:= y - py
}

; fnbar: 0 = horizontal, 1 = vertical, 2 = hWnd is a scroll bar
GetScrollInfo(hWnd, fnBar:= 1) {
	Local o:= {}
	NumPut(VarSetCapacity(SCROLLINFO, 28, 0), SCROLLINFO, 0, "UInt")
	NumPut(0x1F, SCROLLINFO, 4, "UInt") ; fMask: SIF_ALL
	DllCall("GetScrollInfo", "Ptr", hWnd, "Int", fnBar, "Ptr", &SCROLLINFO)
	o.Min := NumGet(SCROLLINFO, 8, "Int")
	o.Max := NumGet(SCROLLINFO, 12, "Int")
	o.Page:= NumGet(SCROLLINFO, 16, "UInt")
	o.Pos := NumGet(SCROLLINFO, 20, "Int")
	return, o
}

ShowScrollBarInfo:
	V:= H:= "No"
	WinGet Style, Style, ahk_id %g_hWnd%
	WinGetClass Class, ahk_id %g_hWnd%

	if (Class == "ScrollBar") {
		if (Style & 1) { ; SBS_VERT
			V:= "Yes"
			VSB:= GetScrollInfo(g_hWnd, 2)
		} else {
			H:= "Yes"
			HSB:= GetScrollInfo(g_hWnd, 2)
		}
	} else {
		if (Style & 0x200000) { ; WS_VSCROLL
			V:= "Yes"
		}
		if (Style & 0x100000) { ; WS_HSCROLL
			H:= "Yes"
		}

		HSB:= GetScrollInfo(g_hWnd, 0)
		VSB:= GetScrollInfo(g_hWnd, 1)
	}

	HPercent:= (HSB.Pos) ? " (" . Round(HSB.Pos / (HSB.Max - HSB.Min) * 100) . "%)" : ""
	VPercent:= (VSB.Pos) ? " (" . Round(VSB.Pos / (VSB.Max - VSB.Min) * 100) . "%)" : ""

	gui ScrollInfo: New, LabelScrollInfo hWndhScrollInfo -MinimizeBox OwnerSpy
	SetWindowIcon(hScrollInfo, ResDir . "\TreeIcons.icl", 31)
	gui Font, s9, Segoe UI
	gui Color, black
	gui Add, CheckBox, w0 y0

	gui Add, GroupBox, x15 y13 w148 h152, Horizontal Scrollbar
	gui Add, Text, x24 y32 w60 h23 +0x200, Visible:
	gui Add, Edit, x86 y36 w60 h21 -E0x200, %H%
	gui Add, Text, x24 y57 w60 h23 +0x200, Minimum:
	gui Add, Edit, x86 y61 w60 h21 -E0x200, % HSB.Min
	gui Add, Text, x24 y82 w60 h23 +0x200, Maximum:
	gui Add, Edit, x86 y86 w60 h21 -E0x200, % HSB.Max
	gui Add, Text, x24 y107 w60 h23 +0x200, Position:
	gui Add, Edit, x86 y111 w70 h21 -E0x200, % HSB.Pos . HPercent
	gui Add, Text, x24 y132 w60 h23 +0x200, Page size:
	gui Add, Edit, x86 y136 w60 h21 -E0x200, % HSB.Page

	gui Add, GroupBox, x178 y13 w148 h152, Vertical Scrollbar
	gui Add, Text, x188 y32 w56 h23 +0x200, Visible:
	gui Add, Edit, x250 y36 w60 h21 -E0x200, %V%
	gui Add, Text, x188 y57 w56 h23 +0x200, Minimum:
	gui Add, Edit, x250 y61 w60 h21 -E0x200, % VSB.Min
	gui Add, Text, x188 y82 w56 h23 +0x200, Maximum:
	gui Add, Edit, x250 y86 w60 h21 -E0x200, % VSB.Max
	gui Add, Text, x188 y107 w56 h23 +0x200, Position:
	gui Add, Edit, x250 y111 w70 h21 -E0x200, % VSB.Pos . VPercent
	gui Add, Text, x188 y132 w56 h23 +0x200, Page size:
	gui Add, Edit, x250 y136 w60 h21 -E0x200, % VSB.Page

	gui Add, Text, x-1 y180 w343 h50 -Background +Border
	gui Add, Button, gScrollInfoClose x247 y193 w84 h24 +Default, &OK

	WinGetPos, X, Y,,, ahk_id %hSpyWnd%
	x += 30
	y += 109
	gui Show, x%x% y%y% w341 h229, Scrollbars
return,

ScrollInfoEscape:
ScrollInfoClose:
	gui ScrollInfo: Destroy
return,

GetSysColorName(Value) {
	Static SysColors:= {0: "COLOR_SCROLLBAR"
	, 1: "COLOR_BACKGROUND"
	, 2: "COLOR_ACTIVECAPTION"
	, 3: "COLOR_INACTIVECAPTION"
	, 4: "COLOR_MENU"
	, 5: "COLOR_WINDOW"
	, 6: "COLOR_WINDOWFRAME"
	, 7: "COLOR_MENUTEXT"
	, 8: "COLOR_WINDOWTEXT"
	, 9: "COLOR_CAPTIONTEXT"
	, 10: "COLOR_ACTIVEBORDER"
	, 11: "COLOR_INACTIVEBORDER"
	, 12: "COLOR_APPWORKSPACE"
	, 13: "COLOR_HIGHLIGHT"
	, 14: "COLOR_HIGHLIGHTTEXT"
	, 15: "COLOR_BTNFACE"
	, 16: "COLOR_BTNSHADOW"
	, 17: "COLOR_GRAYTEXT"
	, 18: "COLOR_BTNTEXT"
	, 19: "COLOR_INACTIVECAPTIONTEXT"
	, 20: "COLOR_BTNHIGHLIGHT"
	, 21: "COLOR_3DDKSHADOW"
	, 22: "COLOR_3DLIGHT"
	, 23: "COLOR_INFOTEXT"
	, 24: "COLOR_INFOBK"
	, 26: "COLOR_HOTLIGHT"
	, 27: "COLOR_GRADIENTACTIVECAPTION"
	, 28: "COLOR_GRADIENTINACTIVECAPTION"
	, 29: "COLOR_MENUHILIGHT"
	, 30: "COLOR_MENUBAR"}

	Color:= SysColors[Value]
	return, (Color == "") ? Value : Color
}

GetWindowPos(hWnd, ByRef X, ByRef Y, ByRef W, ByRef H) {
	VarSetCapacity(RECT, 16, 0)
	DllCall("GetWindowRect", "Ptr", hWnd, "Ptr", &RECT)
	DllCall("MapWindowPoints", "Ptr", 0, "Ptr", GetParent(hWnd), "Ptr", &RECT, "UInt", 2)
	X:= NumGet(RECT, 0, "Int")
	Y:= NumGet(RECT, 4, "Int")
	w:= NumGet(RECT, 8, "Int") - X
	H:= NumGet(RECT, 12, "Int") - Y
}

FindToolHandler:
	if (g_Minimize) {
		WinMove ahk_id %hSpyWnd%,,,,, 78
		g_Minimized:= True
	}

	Dragging:= True

	guiControl,, %hFindTool%, %Bitmap2%

	DllCall("SetCapture", "Ptr", hSpyWnd)
	hOldCursor:= DllCall("SetCursor", "Ptr", hCrossHair, "Ptr")
return,

OnWM_MOUSEMOVE(wParam, lParam, msg, hWnd) {
	global hOldWnd
	if (Dragging) {
		MouseGetPos x, y, hWin, hCtl, 2
		g_hWnd:= (hCtl=="") ? hWin : hCtl
		
		if (g_MouseCoordMode != "Screen") {
			SendMessage 0x84, 0, % y << 16 | x,, ahk_id %hWnd% ; WM_NCHITTEST
			HitTest:= ErrorLevel
		
			if (HitTest==1 || hCtl != "") { ; 1 = HTCLIENT
				if (g_MouseCoordMode=="Client") {
					GetClientCoords(g_hWnd,x,y)
				} else if (g_MouseCoordMode=="Window") {
					GetWindowCoords(g_hWnd,x,y)
				}
			}
		}
		guiControl, Spy:, EdtCursor, %x%, %y%
		if (g_DetectHidden) {
			g_hWnd:= ControlFromPoint(x,y,g_hWnd)
		}
		if (!(g_hWnd=hOldWnd) && !IsBorder(g_hWnd)) {
							tt()
	ShowBorder(g_hWnd,-1)
			if (IsChild(g_hWnd)) {
			MouseGetPos,,,, ClassNN
				LoadControlInfo(ClassNN)
			} else,LoadWindowInfo()
			Timer("UpdateTitleBar",-1)
		}
		hOldWnd:= g_hWnd
	}
}

OnWM_LBUTTONUP(wParam, lParam, msg, hWnd) {
	if (Dragging) {
		Dragging:= False

		DllCall("ReleaseCapture")
		DllCall("SetCursor", "Ptr", hOldCursor)
		guiControl,, %hFindTool%, %Bitmap1%

		Loop 4 {
			Index:= A_Index + 90
			gui %Index%: Destroy
		}

		MouseGetPos,,,, ClassNN
		ShowWindowInfo()

		if (g_Minimized) {
			if (Workaround) {
				SendMessage 0x130C, 1, 0,, ahk_id %hTab% ; TCM_SETCURSEL
				SendMessage 0x1330, 0, 0,, ahk_id %hTab% ; TCM_SETCURFOCUS
				Sleep 0
				SendMessage 0x130C, 0, 0,, ahk_id %hTab% ; TCM_SETCURSEL
				Workaround:= False
			}

			WinMove ahk_id %hSpyWnd%,,,,, 493
		}
	}
}

SetWindowIcon(hWnd, Filename, Index:= 1) {
	Local hSmIcon:= LoadPicture(Filename, "w16 Icon" . Index, ErrorLevel)
	SendMessage 0x80, 0, hSmIcon,, ahk_id %hWnd% ; WM_SETICON, ICON_SMALL
	return, ErrorLevel
}

GetWindowPlacement(hWnd) {
	VarSetCapacity(WINDOWPLACEMENT, 44, 0)
	NumPut(44, WINDOWPLACEMENT)
	DllCall("GetWindowPlacement", "Ptr", hWnd, "Ptr", &WINDOWPLACEMENT)
	Result:= {}
	Result.x:= NumGet(WINDOWPLACEMENT, 7 * 4, "UInt")
	Result.y:= NumGet(WINDOWPLACEMENT, 8 * 4, "UInt")
	Result.w:= NumGet(WINDOWPLACEMENT, 9 * 4, "UInt") - Result.x
	Result.h:= NumGet(WINDOWPLACEMENT, 10 * 4, "UInt") - Result.y
	Result.showCmd:= NumGet(WINDOWPLACEMENT, 8, "UInt")
	; 1 = normal, 2 = minimized, 3 = maximized
	return, Result
}

GetWindowInfo(hWnd) {
	NumPut(VarSetCapacity(WINDOWINFO, 60, 0), WINDOWINFO)
	DllCall("GetWindowInfo", "Ptr", hWnd, "Ptr", &WINDOWINFO)
	wi:= Object()
	wi.WindowX:= NumGet(WINDOWINFO, 4, "Int")
	wi.WindowY:= NumGet(WINDOWINFO, 8, "Int")
	wi.WindowW:= NumGet(WINDOWINFO, 12, "Int") - wi.WindowX
	wi.WindowH:= NumGet(WINDOWINFO, 16, "Int") - wi.WindowY
	wi.ClientX:= NumGet(WINDOWINFO, 20, "Int")
	wi.ClientY:= NumGet(WINDOWINFO, 24, "Int")
	wi.ClientW:= NumGet(WINDOWINFO, 28, "Int") - wi.ClientX
	wi.ClientH:= NumGet(WINDOWINFO, 32, "Int") - wi.ClientY
	wi.Style  := NumGet(WINDOWINFO, 36, "UInt")
	wi.ExStyle:= NumGet(WINDOWINFO, 40, "UInt")
	wi.Active := NumGet(WINDOWINFO, 44, "UInt")
	wi.BorderW:= NumGet(WINDOWINFO, 48, "UInt")
	wi.BorderH:= NumGet(WINDOWINFO, 52, "UInt")
	wi.Atom   := NumGet(WINDOWINFO, 56, "UShort")
	wi.Version:= NumGet(WINDOWINFO, 58, "UShort")
	return, wi
}

GetParent(hWnd) {
	return, DllCall("GetParent", "Ptr", hWnd, "Ptr")
}

GetOwner(hWnd) {
	return, DllCall("GetWindow", "Ptr", hWnd, "UInt", 4, "Ptr") ; GW_OWNER
}

ShowWindow(hWnd, nCmdShow:= 1) {
	DllCall("ShowWindow", "Ptr", hWnd, "Int", nCmdShow)
}

IsWindow(hWnd) {
	return, DllCall("IsWindow", "Ptr", hWnd)
}

IsWindowVisible(hWnd) {
	return, DllCall("IsWindowVisible", "Ptr", hWnd)
}

GetMenu(hWnd) {
	return, DllCall("GetMenu", "Ptr", hWnd, "Ptr")
}

GetSubMenu(hMenu, nPos) {
	return, DllCall("GetSubMenu", "Ptr", hMenu, "Int", nPos, "Ptr")
}

GetMenuItemCount(hMenu) {
	return, DllCall("GetMenuItemCount", "Ptr", hMenu)
}

GetMenuItemID(hMenu, nPos) {
	return, DllCall("GetMenuItemID", "Ptr", hMenu, "Int", nPos)
}

GetMenuString(hMenu, uIDItem) {
	; uIDItem: the zero-based relative position of the menu item
	Local lpString, MenuItemID
	VarSetCapacity(lpString, 4096)
	if !(DllCall("GetMenuString", "Ptr", hMenu, "UInt", uIDItem, "Str", lpString, "Int", 4096, "UInt", 0x400)) {
		MenuItemID:= GetMenuItemID(hMenu, uIDItem)
		if (MenuItemID > -1) {
			return, "SEPARATOR"
		} else {
			return, (GetSubMenu(hMenu, uIDItem)) ? "SUBMENU" : "ERROR"
		}
	}
	return, lpString
}

GetClassName(hWnd) {
	WinGetClass Class, ahk_id %hWnd%
	return, Class
}

GetFileIcon(File, SmallIcon:= 1) {
	VarSetCapacity(SHFILEINFO, cbFileInfo:= A_PtrSize + 688)
	if (DllCall("Shell32.dll\SHGetFileInfoW"
		, "WStr", File
		, "UInt", 0
		, "Ptr" , &SHFILEINFO
		, "UInt", cbFileInfo
		, "UInt", 0x100 | SmallIcon)) { ; SHGFI_ICON
		return, NumGet(SHFILEINFO, 0, "Ptr")
	}
}

SetWindowPos(hWnd, x, y, w, h, hWndInsertAfter:= 0, uFlags:= 0x40) { ; SWP_SHOWWINDOW
	return, DllCall("SetWindowPos", "Ptr", hWnd, "Ptr", hWndInsertAfter, "Int", x, "Int", y, "Int", w, "Int", h, "UInt", uFlags)
}

ShowSettingsDlg:
	gui Settings: New, LabelSettings hWndhSettingsDlg -MinimizeBox OwnerSpy
	SetWindowIcon(hSettingsDlg, ResDir . "\Settings.ico")
	gui Font, s9, Segoe UI
	gui Color, black

	gui Add, GroupBox, x8 y7 w319 h56, %AppName%
	gui Add, CheckBox, vg_AlwaysOnTop x20 y27 w291 h23 Checked%g_AlwaysOnTop%, Show the window always on top

	gui Add, GroupBox, x8 y69 w319 h152, Screenshot
	gui Add, Radio, % "x20 y88 w290 h23 " . (!g_ShowBorder ? "Checked" : "")
	, Capture the contents of the control only
	gui Add, Radio, vg_ShowBorder x20 y118 w290 h23 Checked%g_ShowBorder%
	, Display a border around the control
	gui Add, Text, x36 y150 w78 h23 +0x200, Border color:
	gui Add, Progress, vBorderColorPreview x119 y151 w23 h23 +0x800000 c%g_BorderColor%, 100
	gui Add, Button, gChooseBorderColor x150 y150 w80 h24, Choose
	gui Add, Text, x36 y183 w79 h23 +0x200, Border width:
	gui Add, Edit, vg_BorderWidth x119 y184 w42 h21
	gui Add, UpDown, x159 y184 w18 h21, %g_BorderWidth%

	gui Add, Text, x-1 y231 w338 h48 -Background +Border
	gui Add, Button, gApplySettings x152 y243 w84 h24 +Default, &OK
	gui Add, Button, gSettingsClose x243 y243 w84 h24, &Cancel
	gui Show, w335 h278, Settings
return,

SettingsEscape:
SettingsClose:
	gui Settings: Destroy
return,

ApplySettings:
	gui Settings: Submit
	WinSet AlwaysOnTop, % g_AlwaysOnTop ? "On" : "Off", ahk_id %hSpyWnd%
	g_ShowBorder:= (g_ShowBorder == 2) ? 1 : 0
	g_BorderColor:= g_BorderColorTemp
return,

ChooseBorderColor:
	g_BorderColorTemp:= g_BorderColor
	if (ChooseColor(g_BorderColorTemp, hSettingsDlg)) {
		guiControl, Settings: +c%g_BorderColorTemp%, BorderColorPreview
	}
return,

ChooseColor(ByRef Color, hOwner:= 0) {
	rgbResult:= ((Color & 0xFF) << 16) + (Color & 0xFF00) + ((Color >> 16) & 0xFF)

	VarSetCapacity(CUSTOM, 64, 0)
	NumPut(VarSetCapacity(CHOOSECOLOR, A_PtrSize * 9, 0), CHOOSECOLOR, 0)
	NumPut(hOwner, CHOOSECOLOR, A_PtrSize)
	NumPut(rgbResult, CHOOSECOLOR, A_PtrSize * 3)
	NumPut(&CUSTOM, CHOOSECOLOR, A_PtrSize * 4) ; COLORREF *lpCustColors
	NumPut(0x103, CHOOSECOLOR, A_PtrSize * 5) ; Flags: CC_ANYCOLOR | CC_RGBINIT | CC_FULLOPEN

	RetVal:= DllCall("comdlg32\ChooseColorA", "Str", CHOOSECOLOR)
	if (ErrorLevel != 0 || RetVal == 0) {
		return, False
	}

	rgbResult:= NumGet(CHOOSECOLOR, A_PtrSize * 3)
	Color:= (rgbResult & 0xFF00) + ((rgbResult & 0xFF0000) >> 16) + ((rgbResult & 0xFF) << 16)
	Color:= Format("0x{:06X}", Color)
	return, True
}

OnWM_SYSCOMMAND(wParam, lParam, msg, hWnd) {
	if (wParam == 0xC0DE) {
		gui Spy: +OwnDialogs
		MsgBox 0x40040, About, %AppName% %Version%`nWindow information tool`n`nCredits:`n - J Brown (WinSpy++ developer)`n - Lexicos (AutoHotkey developer)
	}
}

ShowFindDlg:
	if (FindDlgExist) {
		gui Find: Show
	} else {
		gui Find: New, LabelFind hWndhFindDlg
		gui Font, s9, Segoe UI
		gui Color, black

		gui Add, Text, x15 y16 w81 h23 +0x200, Text or Title:
		gui Add, Edit, hWndhEdtFindByText vEdtFindByText gFindWindow x144 y17 w286 h21
		gui Add, CheckBox, vChkFindRegEx x441 y16 w120 h23, Regular Expression
		gui Add, Text, x15 y54 w79 h23 +0x200, Class Name:
		gui Add, ComboBox, vCbxFindByClass gFindWindow x144 y54 w286
		gui Add, Text, x15 y93 w110 h23 +0x200, Process ID or Name:
		gui Add, ComboBox, vCbxFindByProcess gFindWindow x144 y93 w286

		gui Add, ListView, hWndhFindList gFindListHandler x10 y130 w554 h185 +LV0x14000
		, hWnd|Class|Text|Process
		LV_ModifyCol(1, 0)
		LV_ModifyCol(2, 133)
		LV_ModifyCol(3, 285)
		LV_ModifyCol(4, 112)

		gui Add, Text, x-1 y329 w576 h49 +Border -Background
		gui Add, Button, gFindOK x381 y342 w88 h25 Default, &OK
		gui Add, Button, gFindClose x477 y342 w88 h25, &Cancel
 
		gui Show, w574 h377, Find Window
		SetExplorerTheme(hFindList)

		FindDlgExist:= True
	}

	; Unique class names
	Global Classes:= []
	WinGet WinList, List
	Loop %WinList% {
		hThisWnd:= WinList%A_Index%
		WinGetClass WClass, ahk_id %hThisWnd%
		AddUniqueClass(WClass)

		WinGet ControlList, ControlListHwnd, ahk_id %hThisWnd%
		Loop Parse, ControlList, `n
		{
			WinGetClass CClass, ahk_id %A_LoopField%
			AddUniqueClass(CClass)
		}
	}

	ClassList:= ""
	Loop % Classes.Length()  {
		ClassList .= Classes[A_Index] . "|"
	}

	guiControl,, CbxFindByClass, %ClassList%

	; Unique process names
	Processes:= []
	For Process in ComObjGet("winmgmts:").ExecQuery("Select * from Win32_Process") {
		if (Process.ProcessID < 10) {
			Continue
		}

		Unique:= True
		Loop % Processes.Length() {
			if (Process.Name == Processes[A_Index]) {
				Unique:= False
				Break
			}
		}

		if (Unique) {
			Processes.Push(Process.Name)
		}
	}

	ProcList:= ""
	MaxItems:= Processes.Length()
	Loop %MaxItems%  {
		ProcList .= Processes[MaxItems - A_Index + 1] . "|"
	}

	guiControl,, CbxFindByProcess, %ProcList%
return,

AddUniqueClass(ClassName) {
	Local Unique:= True
	Loop % Classes.Length() {
		if (ClassName == Classes[A_Index]) {
			Unique:= False
			Break
		}
	}

	if (Unique) {
		Classes.Push(ClassName)
	}
}

FindEscape:
FindClose:
	gui Find: Hide
return,

FindWindow:
	gui Find: Submit, NoHide

	gui ListView, %hFindList%
	guiControl -Redraw, %hFindList%
	LV_Delete()

	WinGet WinList, List
	Loop %WinList% {
		hThisWnd:= WinList%A_Index%
		if (hThisWnd == hFindDlg) {
			Continue
		}

		WinGetClass WClass, ahk_id %hThisWnd%
		WinGetTitle WTitle, ahk_id %hThisWnd%
		WinGet WProcess, ProcessName, ahk_id %hThisWnd%
		WinGet WProcPID, PID, ahk_id %hThisWnd%

		if (MatchCriteria(WTitle, WClass, IsNumber(CbxFindByProcess) ? WProcPID : WProcess)) {
			LV_Add("", hThisWnd, WClass, WTitle, WProcess)
		}

		WinGet ControlList, ControlListHwnd, ahk_id %hThisWnd%
		Loop Parse, ControlList, `n
		{
			ControlGetText CText,, ahk_id %A_LoopField%
			WinGetClass CClass, ahk_id %A_LoopField%
			WinGet CProcess, ProcessName, ahk_id %A_LoopField%
			WinGet CProcPID, PID, ahk_id %A_LoopField%

			if (MatchCriteria(CText, CClass, IsNumber(CbxFindByProcess) ? CProcPID : CProcess)) {
				LV_Add("", A_LoopField, CClass, CText, CProcess)
			}
		}
	}

	guiControl +Redraw, %hFindList%
return,

MatchCriteria(Text, Class, Process) {
	Global

	if (EdtFindByText != "") {
		if (ChkFindRegEx) {
			if (RegExMatch(Text, EdtFindByText) < 1) {
				return, False
			}
		} else {
			if (!InStr(Text, EdtFindByText)) {
				return, False
			}
		}
	}

	if (CbxFindByClass != "" && !InStr(Class, CbxFindByClass)) {
		return, False
	}

	if (CbxFindByProcess != "") {
		return, IsNumber(Process) ? CbxFindByProcess == Process : InStr(Process, CbxFindByProcess)
	}

	return, True
}

FindOK:
	gui ListView, %hFindList%
	LV_GetText(hWnd, LV_GetNext())
	guiControl, Spy:, EdtHandle, %hWnd%
	WinActivate ahk_id %hSpyWnd%
	gui Find: Hide
return,

FindListHandler:
	if (A_guiEvent == "DoubleClick") {
		GoSub FindOK
	}
return,

CreateImageList() {
	ImageList:= IL_Create(32)
	IL_Add(ImageList, TreeIcons, 1)  ; Generic window icon
	IL_Add(ImageList, TreeIcons, 2)  ; Desktop (#32769)
	IL_Add(ImageList, TreeIcons, 3)  ; Dialog (#32770)
	IL_Add(ImageList, TreeIcons, 4)  ; Button
	IL_Add(ImageList, TreeIcons, 5)  ; CheckBox
	IL_Add(ImageList, TreeIcons, 6)  ; ComboBox
	IL_Add(ImageList, TreeIcons, 7)  ; DateTime
	IL_Add(ImageList, TreeIcons, 8)  ; Edit
	IL_Add(ImageList, TreeIcons, 9)  ; GroupBox
	IL_Add(ImageList, TreeIcons, 10) ; Hotkey
	IL_Add(ImageList, TreeIcons, 11) ; Icon
	IL_Add(ImageList, TreeIcons, 12) ; Link
	IL_Add(ImageList, TreeIcons, 13) ; ListBox
	IL_Add(ImageList, TreeIcons, 14) ; ListView
	IL_Add(ImageList, TreeIcons, 15) ; MonthCal
	IL_Add(ImageList, TreeIcons, 16) ; Picture
	IL_Add(ImageList, TreeIcons, 17) ; Progress
	IL_Add(ImageList, TreeIcons, 18) ; Radio
	IL_Add(ImageList, TreeIcons, 19) ; RichEdit
	IL_Add(ImageList, TreeIcons, 20) ; Separator
	IL_Add(ImageList, TreeIcons, 21) ; Slider
	IL_Add(ImageList, TreeIcons, 22) ; Status bar
	IL_Add(ImageList, TreeIcons, 23) ; Tab
	IL_Add(ImageList, TreeIcons, 24) ; Text
	IL_Add(ImageList, TreeIcons, 25) ; Toolbar
	IL_Add(ImageList, TreeIcons, 26) ; Tooltips
	IL_Add(ImageList, TreeIcons, 27) ; TreeView
	IL_Add(ImageList, TreeIcons, 28) ; UpDown
	IL_Add(ImageList, TreeIcons, 29) ; IE
	IL_Add(ImageList, TreeIcons, 30) ; Scintilla
	IL_Add(ImageList, TreeIcons, 31) ; ScrollBar
	IL_Add(ImageList, TreeIcons, 32) ; SysHeader
	return, ImageList
}

ShowTree:
	if (WinExist("ahk_id" . hTreeWnd)) {
		gui Tree: Show
		SetWindowIcon(hTreeWnd, "shell32.dll", 42)
	} else {
		gui Tree: New, LabelTree hWndhTreeWnd +Resize
		SetWindowIcon(hTreeWnd, "shell32.dll", 42)

		Menu TreeMenu, Add, &Reload`tF5, LoadTree
		Menu TreeMenu, Add
		Menu TreeMenu, Add, E&xit`tEsc, TreeClose
		Menu MenuBar, Add, &Tree, :TreeMenu
		Menu ViewMenu, Add, Show &Hidden Windows, ToggleHiddenWindows
		Menu ViewMenu, Add
		Menu ViewMenu, Add, &Flash Window`tF6, FlashWindow
		Menu ViewMenu, Add
		Menu ViewMenu, Add, E&xpand All Nodes, ExpandAll
		Menu ViewMenu, Add, &Collapse All Nodes, CollapseAll
		Menu MenuBar, Add, &View, :ViewMenu
		gui Tree: Menu, MenuBar

		gui Font, s9, Segoe UI
		gui Add, TreeView, hWndhTree gTreeHandler x0 y0 w681 h445 -Lines +0x9000

		gui Show, w681 h445, %AppName% - Tree

		TV_SetImageList(CreateImageList())
		SetExplorerTheme(hTree)
	}

	GoSub LoadTree
return,

TreeEscape:
TreeClose:
	gui Tree: Hide
return,

TreeSize:
	if (A_EventInfo == 1) { ; Minimized
		return,
	}

	AutoXYWH("wh", hTree)
return,

LoadTree:
	Global TreeIDs:= {}

	gui Tree: Default
	TV_Delete()

	RootID:= TV_Add("Desktop", 0, "Icon2")
	TreeIDs[RootID]:= DllCall("GetDesktopWindow", "Ptr")

	WinGet WinList, List
	Loop %WinList% {
		hWnd:= WinList%A_Index%

		WinGetClass Class, ahk_id %hWnd%
		WinGetTitle Title, ahk_id %hWnd%
		if (Title != "") {
			Title:= " - " . Title
		}

		Invisible:= !IsWindowVisible(hWnd)

		if (!g_TreeShowAll && Invisible) {
			Continue
		}

		if (Invisible) {
			Title .= " (hidden)"
		}

		Icon:= GetWindowIcon(hWnd, Class, True)

		ID:= TV_Add(Class . Title, RootID, "Icon" . Icon)
		TreeIDs[ID]:= hWnd
		Tree(hWnd, ID)
	}

	TV_Modify(RootID, "+Expand")

	For Key, Value in TreeIDs {
		if (g_hWnd == Value) {
			TV_Modify(Key, "Select")
		}
	}
return,

Tree(hParentWnd, ParentID) {
	WinGet WinList, ControlListHwnd, ahk_id %hParentWnd%
	Loop Parse, WinList, `n
	{
		if (GetParent(A_LoopField) != hParentWnd) {
			Continue
		}

		WinGetClass Class, ahk_id %A_LoopField%
		if (IsChild(A_LoopField)) {
			ControlGetText Text,, ahk_id %A_LoopField%
		} else {
			WinGetTitle Text,, ahk_id %A_LoopField%
		}

		if (Text != "") {
			Text:= " - " . Text
		}

		Invisible:= !IsWindowVisible(A_LoopField)

		if (!g_TreeShowAll && Invisible) {
			Continue
		}

		if (Invisible) {
			Text .= " (hidden)"
		}

		Icon:= GetWindowIcon(A_LoopField, Class)

		ID:= TV_Add(Class . Text, ParentID, "Icon" . Icon)
		TreeIDs[ID]:= A_LoopField
		Tree(A_LoopField, ID)
	}
}

TreeHandler:
	if (A_guiEvent == "DoubleClick") {
		g_hWnd:= TreeIDs[A_EventInfo]
		ShowWindowInfo()
	}
return,

GetWindowIcon(hWnd, Class, TopLevel:= False) {
	Static Classes:= {0:0
	, "#32770": 3
	, "Button": 4
	, "CheckBox": 5
	, "ComboBox": 6
	, "SysDateTimePick32": 7
	, "Edit": 8
	, "GroupBox": 9
	, "msctls_hotkey32": 10
	, "Icon": 11
	, "SysLink": 12
	, "ListBox": 13
	, "SysListView32": 14
	, "SysMonthCal32": 15
	, "Picture": 16
	, "msctls_progress32": 17
	, "Radio": 18
	, "RebarWindow32": 25
	, "RichEdit": 19
	, "Separator": 20
	, "msctls_trackbar32": 21
	, "msctls_statusbar32": 22
	, "SysTabControl32": 23
	, "Static": 24
	, "ToolbarWindow32": 25
	, "tooltips_class32": 26
	, "SysTreeView32": 27
	, "msctls_updown32": 28
	, "Internet Explorer_Server": 29
	, "Scintilla": 30
	, "ScrollBar": 31
	, "SysHeader32": 32}

	if (Class == "Button") {
		WinGet Style, Style, ahk_id %hWnd%
		Type:= Style & 0xF
		if (Type == 7) {
			Class:= "GroupBox"
		} else if (Type ~= "2|3|5|6") {
			Class:= "CheckBox"
		} else if (Type ~= "4|9") {
			Class:= "Radio"
		} else {
			Class:= "Button"
		}
	} else if (Class == "Static") {
		WinGet Style, Style, ahk_id %hWnd%
		Type:= Style & 0x1F ; SS_TYPEMASK
		if (Type == 3) {
			Class:= "Icon"
		} else if (Type == 14) {
			Class:= "Picture"
		} else if (Type == 0x10) {
			Class:= "Separator"
		} else {
			Class:= "Static"
		}
	} else if (InStr(Class, "RICHED", True) == 1) {
		Class:= "RichEdit" ; RICHEDIT50W
	}

	Icon:= Classes[Class]
	if (Icon != "") {
		return, Icon
	}

	SendMessage 0x7F, 2, 0,, ahk_id %hWnd% ; WM_GETICON, ICON_SMALL2
	hIcon:= ErrorLevel

	if (hIcon == 0 && TopLevel) {
		WinGet ProcessPath, ProcessPath, ahk_id %hWnd%
		hIcon:= GetFileIcon(ProcessPath)
	}

	IconIndex:= (hIcon) ? IL_Add(ImageList, "HICON: " . hIcon) : 1
	return, IconIndex
}

ToggleHiddenWindows:
	g_TreeShowAll:= !g_TreeShowAll
	GoSub LoadTree
	Menu ViewMenu, ToggleCheck, Show &Hidden Windows
return,

CollapseAll:
ExpandAll:
	Expand:= (A_ThisLabel == "ExpandAll") ? "+Expand" : "-Expand"

	ItemID:= 0
	Loop {
		ItemID:= TV_GetNext(ItemID, "Full")
		if (!ItemID) {
			Break
		}

		TV_Modify(ItemID, Expand)
	}
return,

FlashWindow:
	if (A_gui == "Tree") {
		hWnd:= TreeIDs[TV_GetSelection()]
	} else {
		hWnd:= g_hWnd
	}

	ShowBorder(hWnd, 200, 0xFF0000)
	Sleep 200
	ShowBorder(hWnd, 200, 0xFF0000)
	Sleep 200
	ShowBorder(hWnd, 200, 0xFF0000)
return,

; Based on a script written by Lexicos
ShowMenuViewer:
	if (MenuViewerExist) {
		gui MenuViewer: Show
	} else {
		gui MenuViewer: New, +LabelMenuViewer +hWndhMenuViewer +Resize
		gui Font, s9, Segoe UI
		gui Color, 0x000000

		gui Add, ListView, hWndhMenuList vLVMenu x0 y0 w600 h400 +LV0x14000, Menu Item String|Keyboard|Menu ID
		LV_ModifyCol(1, 410)
		LV_ModifyCol(2, 103)
		LV_ModifyCol(3, "65 Integer")
		SetExplorerTheme(hMenuList)

		gui Add, Edit, hWndhEdtMenuSearch vEdtMenuSearch gSearchMenu x8 y408 w200 h23 +0x2000000 ; WS_CLIPCHILDREN
		DllCall("SendMessage", "Ptr", hEdtMenuSearch, "UInt", 0x1501, "Ptr", 1, "WStr", "Search")

		gui Add, Picture, hWndhSearchIcon x178 y1 w16 h16, %ResDir%\Search.ico
		DllCall("SetParent", "Ptr", hSearchIcon, "Ptr", hEdtMenuSearch)
		WinSet Style, -0x40000000, ahk_id %hSearchIcon% ; -WS_CHILD
		ControlFocus,, ahk_id %hEdtMenuSearch%

		NoAmpersands:= True
		gui Add, CheckBox, vNoAmpersands gShowMenuItems x220 y408 w167 h23 Checked%NoAmpersands%
		, Remove Ampersands (&&)
		gui Add, Button, vBtnMenuCopy gCopyMenuList x466 y407 w125 h25, Copy to Clipboard
		gui Show, w600 h440, Menu Viewer
		MenuViewerExist:= True
	}

	GoSub ShowMenuItems
return,

ShowMenuItems:
	gui MenuViewer: Default
	gui Submit, NoHide

	LV_Delete()
	hMenu:= GetMenu(g_hWnd)
	if (hMenu) {
		MenuItems:= []
		GetMenuItems(hMenu, "", "")
	}
return,

GetMenuItems(hMenu, Prefix, ByRef Commands) {
	Global
	ItemCount:= GetMenuItemCount(hMenu)

	Loop %ItemCount% {
		ItemString:= GetMenuString(hMenu, A_Index - 1)
		ItemID:= GetMenuItemID(hMenu, A_Index - 1)

		RegExMatch(ItemString, "\t(.+)", Keyboard)
		ItemString:= RegExReplace(ItemString, "\t.*")
		if (ItemString == "SEPARATOR") {
			ItemString:= "----------------------------"
		}

		MenuItems.Push([ItemString, Keyboard1, ItemID])

		if (NoAmpersands) {
			ItemString:= StrReplace(ItemString, "&")
		}

		LV_Add("", Prefix . ItemString, Keyboard1, ItemID)

		if (ItemID == -1) { ; Submenu
			hSubMenu:= GetSubMenu(hMenu, A_Index - 1)
			if (hSubMenu) {
				Prefix .= "		"
				GetMenuItems(hSubMenu, Prefix, Commands)
				Prefix:= StrReplace(Prefix, "		", "",, 1)
				Continue
			}
		}
	}
}

SearchMenu:
gui MenuViewer: Submit, NoHide
gui ListView, %hMenuList%
LV_Delete()

Loop % MenuItems.Length() {
	MenuItem:= MenuItems[A_Index][1]
	Keyboard:= MenuItems[A_Index][2]
	MenuID  := MenuItems[A_Index][3]

	if (NoAmpersands) {
		MenuItem:= StrReplace(MenuItem, "&")
	}

	if (InStr(MenuItem, EdtMenuSearch)
	||  InStr(Keyboard, EdtMenuSearch)
	||  InStr(MenuID, EdtMenuSearch)) {
		LV_Add("", MenuItem, Keyboard, MenuID)
}	}
return,

CopyMenuList:
gui MenuViewer: Default
ControlGet MenuList, List,,, ahk_id %hMenuList%
Clipboard:= StrReplace(MenuList, "		", "`t")
return,

MenuViewerEscape:
MenuViewerClose:
gui MenuViewer: Hide
return,

MenuViewerSize:
if (A_EventInfo == 1) ; Minimized
	return,
AutoXYWH("wh",hMenuList)
AutoXYWH("y", hEdtMenuSearch)
AutoXYWH("y", hSearchIcon)
AutoXYWH("y","NoAmpersands")
AutoXYWH("xy","BtnMenuCopy")
return,

MenuViewerContextMenu:
Row:= LV_GetNext()
LV_GetText(MenuString, Row, 1)
LV_GetText(MenuID, Row, 3)
if (A_guiControl == "LVMenu" && MenuID > 0 && !InStr(MenuString, "-----")) {
	Menu MenuMenu, Add, Invoke Menu Command, InvokeMenuCommand
	Menu MenuMenu, Show
}
return,

InvokeMenuCommand:
PostMessage 0x111, %MenuID%,,, ahk_id %g_hWnd%
return,

LoadProcessProperties:
gui Spy: Submit, NoHide
WinGet PID, PID, ahk_id %g_hWnd%
StrQuery:= "SELECT * FROM Win32_Process WHERE ProcessId=" . PID
Enum:= ComObjGet("winmgmts:").ExecQuery(StrQuery)._NewEnum
if (Enum[Process]) {
	ExePath:= Process.ExecutablePath

	hIcon:= GetFileIcon(ExePath, 0)
	if (!hIcon || ExePath == "") {
		hIcon:= DllCall("LoadIcon", "Ptr", 0, "UInt", 32512, "Ptr") ; IDI_APPLICATION
	}

	guiControl,, ProgIcon, % "HICON:" . hIcon
	guiControl,, ProgName, % Process.Name
	FileGetVersion ProgVer, %ExePath%
	guiControl,, ProgVer, %ProgVer%

	gui ListView, %hProcInfo%
	LV_Delete()
	LV_Add("", "Path", ExePath)
	LV_Add("", "Command line", Process.CommandLine)
	LV_Add("", "Process ID", Process.ProcessId)
	LV_Add("", "Thread ID", DllCall("GetWindowThreadProcessId", "Ptr", g_hWnd, "Ptr", 0))
	CreationDate:= Process.CreationDate
	SubStr(CreationDate, 1, InStr(CreationDate, ".") - 1)
	FormatTime CreationDate, %CreationDate% D1 T0 ; Short date and time with seconds
	LV_Add("", "Started", CreationDate)
	LV_Add("", "Working Size", FormatBytes(Process.WorkingSetSize, Sep))
	LV_Add("", "Virtual Size", FormatBytes(Process.VirtualSize, Sep))
	LV_Add("", "Image Type", GetImageType(PID))
}
return,

GetImageType(PID) {
	; PROCESS_QUERY_INFORMATION
	hProc:= DllCall("OpenProcess", "UInt", 0x400, "Int", False, "UInt", PID, "Ptr")
	if (!hProc) {
		return, "N/A"
	}

	if (A_Is64bitOS) {
		; Determines whether the specified process is running under WOW64.
		Try DllCall("IsWow64Process", "Ptr", hProc, "Int*", Is32Bit:= True)
	} else {
		Is32Bit:= True
	}

	DllCall("CloseHandle", "Ptr", hProc)

	return, (Is32Bit) ? "32-bit" : "64-bit"
}

EndProcess:
	guiControlGet Filename,, ProgName
	if (Filename == "N/A") {
		return,
	}

	gui Spy: +OwnDialogs
	MsgBox 0x40031, %AppName%, Are you sure you want to exit %Filename%?
	IfMsgBox OK, {
		WinGet PID, PID, ahk_id %g_hWnd%
		Process Close, %PID%
		if (ErrorLevel == 0) {
			gui Spy: +OwnDialogs
			MsgBox 0x40010, Error, The process named %Filename% with PID %PID% could not be ended.
		}
	}
return,

OpenFolder:
	gui ListView, %hProcInfo%
	LV_GetText(ExePath, 1, 2)
	if (ExePath != "") {
		Run *open explorer.exe /select`,"%ExePath%"
	}
return,

FormatBytes(Value, sThousand:= ".", Unit:= -1, ShowUnit:= True) {
	if ((Unit == -1 && Value > 999) || Unit == "K") {
		Value /= 1024
		Unit:= ShowUnit ? " K" : ""
	} else {
		Unit:= ShowUnit ? " B" : ""
	}

	a:= ""
	Loop % StrLen(Value) {
		a .= SubStr(Value, 1 - A_Index, 1)
		if (Mod(A_Index, 3) == 0) {
			a .= sThousand
		}
	}

	a:= RTrim(a, sThousand)

	b:= ""
	Loop % StrLen(a) {
		b .= SubStr(a, 1 - A_Index, 1)
	}

	return, b . Unit
}

; http://ahkscript.org/boards/viewtopic.php?t=1079
AutoXYWH(DimSize, cList*) {
	Static cInfo:= {}

	if (DimSize = "reset") {
		return, cInfo:= {}
	}

	For i, ctrl in cList {
		ctrlID:= A_gui ":" ctrl
		if (cInfo[ctrlID].x = "") {
			guiControlGet i, %A_gui%: Pos, %ctrl%
			MMD:= InStr(DimSize, "*") ? "MoveDraw" : "Move"
			fx:= fy:= fw:= fh:= 0
			For i, dim in (a:= StrSplit(RegExReplace(DimSize, "i)[^xywh]"))) {
				if (!RegExMatch(DimSize, "i)" . dim . "\s*\K[\d.-]+", f%dim%)) {
					f%dim%:= 1
				}
			}
			cInfo[ctrlID]:= {x: ix, fx: fx, y: iy, fy: fy, w: iw, fw: fw, h: ih, fh: fh, gw: A_guiWidth, gh: A_guiHeight, a: a, m: MMD}
		} else if (cInfo[ctrlID].a.1) {
			dgx:= dgw:= A_guiWidth - cInfo[ctrlID].gw, dgy:= dgh:= A_guiHeight - cInfo[ctrlID].gh
			Options:= ""
			For i, dim in cInfo[ctrlID]["a"] {
				Options .= dim . (dg%dim% * cInfo[ctrlID]["f" . dim] + cInfo[ctrlID][dim]) . A_Space
			}
			guiControl, % A_gui ":" cInfo[ctrlID].m, % ctrl, % Options
		}
	}
}

IsBorder(hWnd) {
	Loop % g_Borders.Length() {
		if (g_Borders[A_Index] == hWnd) {
			return, True
		}
	}
	return, False
}

IsNumber(n) {
	if n Is Number
		return, True
	return, False
}

ShowHelp:
gui Spy: +OwnDialogs
MsgBox 0x40, %AppName% Keyboard Shortcuts, 
(
F2:  Go to the parent window
F3:  Show the Find dialog
F4:  Show the hierarchical window tree
F5:  Reload window information
F6:  Highlight window location
F7:  Position and Size dialog
F8:  Copy information to the clipboard
F9:  Copy screenshot to the clipboard
)
return,


Open_Script_Location: ;run %a_scriptDir%
toolTip %a_scriptFullPath%
E=explorer.exe /select,%a_scriptFullPath%
run %comspec% /C %E%,, hide
return,